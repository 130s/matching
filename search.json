[
  {
    "objectID": "docs/tutorials/student_allocation.html",
    "href": "docs/tutorials/student_allocation.html",
    "title": "Producing a final-year project allocation",
    "section": "",
    "text": "In this tutorial we will be solving an instance of SA using raw, tabular data.\nThis tutorial covers all aspects of the project allocation process, from wrangling the data, all the way through to analysing the results. In fact, this tutorial has been used to train staff at Cardiff University in performing automatic project allocation.\nimport numpy as np\nimport pandas as pd\n\npd.set_option(\"display.max_columns\", None)\nThe data for this tutorial have been archived on Zenodo, and the source code used to generate them is here.\nraw_students = pd.read_csv(\n    \"https://zenodo.org/record/3514287/files/students.csv\"\n)\nraw_projects = pd.read_csv(\n    \"https://zenodo.org/record/3514287/files/projects.csv\"\n)\nraw_supervisors = pd.read_csv(\n    \"https://zenodo.org/record/3514287/files/supervisors.csv\"\n)"
  },
  {
    "objectID": "docs/tutorials/student_allocation.html#cleaning-the-data",
    "href": "docs/tutorials/student_allocation.html#cleaning-the-data",
    "title": "Producing a final-year project allocation",
    "section": "Cleaning the data",
    "text": "Cleaning the data\nIn order to use Matching’s implementation of SA, we require the data to be “clean”. This process will require us to inspect the data and remove any erroneous rows from each of our datasets.\n\nStudents\nWe begin with the students. The first thing we have to do is find out how many choices students were allowed to make:\n\nraw_students.columns\n\nIndex(['name', 'rank', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10',\n       '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22',\n       '23', '24'],\n      dtype='object')\n\n\nWe can see that students could make up to 25 selections, and the choice columns are numbered 0 through 24.\n\nn_choices = 25\nchoices = map(str, range(n_choices))\n\nNow we want to get rid of any students that didn’t make any choices.\n\nstudents = (\n    raw_students.copy()\n    .dropna(subset=choices, how=\"all\")\n    .reset_index(drop=True)\n)\n\nstudents.head()\n\n\n\n\n\n\n\n\nname\nrank\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n0\n190000\n3\nG2\nP1\nV2\nS0\nA0\nO0\nL0\nD2\nK1\nV1\nR2\nG2\nY2\nG2\nW0\nK0\nX0\nO1\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n190001\n56\nQ0\nP1\nP0\nM1\nN0\nP1\nT2\nN1\nI1\nK0\nP3\nX1\nF0\nP1\nS0\nC0\nZ0\nL0\nH2\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n2\n190002\n60\nD0\nU0\nY1\nE2\nR0\nP0\nV1\nR2\nX1\nY0\nR1\nI1\nT1\nV1\nY2\nA1\nI2\nN1\nA0\nJ2\nA0\nNaN\nNaN\nNaN\nNaN\n\n\n3\n190003\n67\nC0\nJ1\nI2\nN1\nW1\nE1\nM1\nZ1\nQ0\nB1\nO0\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n4\n190004\n19\nI0\nM1\nC2\nD0\nW0\nF1\nB2\nO1\nT0\nL0\nW1\nX2\nW0\nN0\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\nWe can see that, in fact, some students won’t be included in this game:\n\nlen(raw_students) - len(students)\n\n3\n\n\n\n\nProjects\nNow that students are done, we can move onto the projects.\nEach project needs a code, a supervisor and a non-zero capacity. We drop any project that is missing any of these items.\n\nprojects = raw_projects.copy()\nprojects = projects.dropna()\nprojects = projects[projects[\"capacity\"] &gt; 0]\n\nprojects.head()\n\n\n\n\n\n\n\n\ncode\ncapacity\nsupervisor\n\n\n\n\n0\nA0\n2\nA\n\n\n1\nA1\n3\nA\n\n\n2\nA2\n2\nA\n\n\n3\nB0\n2\nB\n\n\n4\nB1\n2\nB\n\n\n\n\n\n\n\nVerify that no projects were lost:\n\nlen(raw_projects) == len(projects)\n\nTrue\n\n\n\n\nSupervisors\nEach supervisor requires a unique name and a non-zero capacity. We drop any supervisor without either of these things.\n\nsupervisors = raw_supervisors.copy()\nsupervisors = supervisors.dropna()\nsupervisors = supervisors[supervisors[\"capacity\"] &gt; 0]\n\nsupervisors.head()\n\n\n\n\n\n\n\n\nname\ncapacity\n\n\n\n\n0\nA\n3\n\n\n1\nB\n1\n\n\n2\nC\n8\n\n\n3\nD\n5\n\n\n4\nE\n2\n\n\n\n\n\n\n\nVerify no supervisors were lost:\n\nlen(supervisors) == len(raw_supervisors)\n\nTrue"
  },
  {
    "objectID": "docs/tutorials/student_allocation.html#creating-the-dictionaries",
    "href": "docs/tutorials/student_allocation.html#creating-the-dictionaries",
    "title": "Producing a final-year project allocation",
    "section": "Creating the dictionaries",
    "text": "Creating the dictionaries\nWith the now clean data, Python dictionaries must be created that we can pass to Matching. These dictionaries detail the following relationships:\n\nProject supervisor affiliations\nProject capacities\nSupervisor capacities\nStudent preference lists\nSupervisor preference lists\n\n\nCapacities and affiliations\nWe’ll begin with the capacity and affiliation dictionaries for projects. With both dictionaries, a project is only added if both their capacity and the capacity of their supervisor is non-zero.\n\nsupervisor_names = supervisors[\"name\"].values\nproject_codes = projects[\"code\"].values\n\n\nproject_to_capacity, project_to_supervisor = {}, {}\nfor _, (project, capacity, supervisor) in projects.iterrows():\n    if project in project_codes and supervisor in supervisor_names:\n        project_to_supervisor[project] = supervisor\n        project_to_capacity[project] = capacity\n\nNow we can create the supervisor capacity dictionary. In this case, we only include a supervisor if they have at least one valid project.\n\nsupervisor_to_capacity = {}\nfor _, (supervisor, capacity) in supervisors.iterrows():\n    if supervisor in project_to_supervisor.values():\n        supervisor_to_capacity[supervisor] = capacity\n\n\n\nPreference lists (dictionaries)\nThe only remaining dictionaries are for the preference lists of the students and the supervisors.\nLet’s begin with the students.\nAs is discussed here, students must have a strict, unique preference of some non-empty subset of the projects. This means that if a student ranks no projects, they are excluded from the game.\n.. note:: In the case where a student ranks the same project more than once, we take their highest ranking of it and shift everything else up.\n\nstudent_to_preferences = {}\nfor _, (student, _, *prefs) in students.iterrows():\n    student_preferences = []\n    for project in prefs:\n        if project in project_codes and project not in student_preferences:\n            student_preferences.append(project)\n\n    if student_preferences:\n        student_to_preferences[student] = student_preferences\n\nWith that done, we’re only left with the supervisors’ preferences.\nAs is often the case in real-world instances of SA, each student is assigned a unique rank in their cohort. This ranking is typically done independently of the supervisors to make the game as fair as possible. In cases where “backroom” deals are allowed between supervisors and students, the overall effect is that everyone is worse off.\n\nsorted_students = students.sort_values(\"rank\", ascending=True)[\"name\"].values\n\nThis complete ranking of the students allows the supervisors to draw their preference list from the same source.\nAs is discussed here, each supervisor must rank all (and only) those students who have ranked at least one of their projects.\n\n\n\n\n\n\nNote\n\n\n\nIf a student has ranked multiple projects from the same supervisor, they still only appear once in the supervisor’s preference list. As with students, if a supervisor’s preference list is empty (i.e. none of their projects were ranked by any student) then they are excluded from the game.\n\n\n\nsupervisor_to_preferences = {}\nfor supervisor in supervisor_names:\n    supervisor_preferences = []\n    supervisor_projects = [\n        p for p, s in project_to_supervisor.items() if s == supervisor\n    ]\n\n    for student in sorted_students:\n        student_preferences = student_to_preferences[student]\n        if set(student_preferences).intersection(supervisor_projects):\n            supervisor_preferences.append(student)\n\n    if supervisor_preferences:\n        supervisor_to_preferences[supervisor] = supervisor_preferences"
  },
  {
    "objectID": "docs/tutorials/student_allocation.html#final-clean-up",
    "href": "docs/tutorials/student_allocation.html#final-clean-up",
    "title": "Producing a final-year project allocation",
    "section": "Final clean up",
    "text": "Final clean up\nWe’re almost there but now we need to adjust the entries in our dictionaries that don’t make sense anymore.\n\nRemoving extra players from the game\nTo begin, we have to go back through supervisor_to_capacity to remove any unranked supervisors. Likewise for unranked projects but we must also remove them from project_to_supervisor.\nIt should follow that if a supervisor is unranked then none of their projects are either.\n\nunranked_supervisors = set(supervisor_names).difference(\n    supervisor_to_preferences.keys()\n)\n\n\nunranked_projects = set(project_codes).difference(\n    (project for prefs in student_to_preferences.values() for project in prefs)\n)\n\nunranked_supervisors, unranked_projects\n\n(set(), {'L1'})\n\n\n\nfor supervisor in unranked_supervisors:\n    del supervisor_to_capacity[supervisor]\n\nfor project in unranked_projects:\n    del project_to_capacity[project]\n    del project_to_supervisor[project]\n\n\n\nChecking and adjusting capacities\nThe final step is to adjust the capacities. There are some stipulations on the capacities of projects and their supervisors:\n\nEach project’s capacity must be no larger than that of its supervisor.\nEach supervisor’s capacity must be:\n\nAt least as large as its largest project’s capacity.\nNo larger than the sum of its projects’ capacities.\n\n\nWe begin by reducing the capacities of too-large projects. This means that no supervisor will have to increase their capacity for the sake of a single project, and we don’t need to worry about the first point in (2).\n\nfor project, project_capacity in project_to_capacity.items():\n    supervisor = project_to_supervisor[project]\n    supervisor_capacity = supervisor_to_capacity[supervisor]\n\n    if project_capacity &gt; supervisor_capacity:\n        print(\n            f\"{project} has a capacity of {project_capacity} but\",\n            f\"{supervisor} has capacity {supervisor_capacity}.\",\n        )\n        project_to_capacity[project] = supervisor_capacity\n\nB0 has a capacity of 2 but B has capacity 1.\nB1 has a capacity of 2 but B has capacity 1.\nB2 has a capacity of 2 but B has capacity 1.\nE1 has a capacity of 3 but E has capacity 2.\nE2 has a capacity of 3 but E has capacity 2.\nF1 has a capacity of 3 but F has capacity 2.\nI1 has a capacity of 2 but I has capacity 1.\nI2 has a capacity of 2 but I has capacity 1.\nM0 has a capacity of 8 but M has capacity 7.\nO1 has a capacity of 2 but O has capacity 1.\nQ0 has a capacity of 2 but Q has capacity 1.\nR0 has a capacity of 2 but R has capacity 1.\nR2 has a capacity of 2 but R has capacity 1.\nS1 has a capacity of 7 but S has capacity 6.\nT2 has a capacity of 2 but T has capacity 1.\nU0 has a capacity of 6 but U has capacity 5.\nV1 has a capacity of 3 but V has capacity 2.\nV2 has a capacity of 3 but V has capacity 2.\nX0 has a capacity of 8 but X has capacity 7.\n\n\nNow we can make sure that no supervisor is providing more spaces than they’re offering through their projects.\n\nfor supervisor, supervisor_capacity in supervisor_to_capacity.items():\n    supervisor_projects = [\n        p for p, s in project_to_supervisor.items() if s == supervisor\n    ]\n    supervisor_project_capacities = [\n        project_to_capacity[project] for project in supervisor_projects\n    ]\n\n    if supervisor_capacity &gt; sum(supervisor_project_capacities):\n        print(\n            f\"{supervisor} has capacity {supervisor_capacity} but their projects\",\n            f\"{', '.join(supervisor_projects)} have a total capacity of\",\n            f\"{sum(supervisor_project_capacities)}.\",\n        )\n        supervisor_to_capacity[supervisor] = sum(supervisor_project_capacities)\n\nK has capacity 8 but their projects K0, K1, K2 have a total capacity of 6.\nL has capacity 2 but their projects L0 have a total capacity of 1.\nW has capacity 5 but their projects W0, W1 have a total capacity of 2."
  },
  {
    "objectID": "docs/tutorials/student_allocation.html#playing-the-game",
    "href": "docs/tutorials/student_allocation.html#playing-the-game",
    "title": "Producing a final-year project allocation",
    "section": "Playing the game",
    "text": "Playing the game\nNow that we have formulated our players according to the rules of the game, we are ready to play it.\nMatching has an implementation of the SA algorithm which takes the dictionaries we’ve built as parameters. From there, the game can be solved to be student- or supervisor-optimal. We’ll be using the former.\n\nfrom matching.games import StudentAllocation\n\n\ngame = StudentAllocation.create_from_dictionaries(\n    student_to_preferences,\n    supervisor_to_preferences,\n    project_to_supervisor,\n    project_to_capacity,\n    supervisor_to_capacity,\n)\n\nmatching = game.solve(optimal=\"student\")\nassert game.check_validity()\nassert game.check_stability()\n\n\nmatching\n\n{A0: [], A1: [190019, 190034], A2: [190017], B0: [], B1: [190091], B2: [], C0: [190003, 190068], C1: [190070], C2: [190079, 190062], D0: [190015, 190039, 190009], D1: [190008, 190056], D2: [], E0: [], E1: [190063, 190022], E2: [], F0: [190011], F1: [190094], G0: [190096], G1: [], G2: [190000, 190045, 190077], H0: [], H1: [190078], H2: [190023, 190098], I0: [190004], I1: [], I2: [], J0: [190021], J1: [190097, 190089, 190061, 190014], J2: [190085, 190090], K0: [190074, 190095], K1: [190024, 190013], K2: [190052, 190006], L0: [190072], M0: [190086, 190053], M1: [190054, 190081, 190075], N0: [190049, 190032], N1: [190046, 190044, 190037, 190057], N2: [190031, 190060], O0: [190016], O1: [], P0: [190047], P1: [190076, 190027], P2: [190093], P3: [190071], Q0: [190001], R0: [190048], R1: [], R2: [], S0: [190069], S1: [190092, 190042, 190084, 190066, 190067], T0: [], T1: [], T2: [190036], U0: [190010, 190002, 190059, 190030], U1: [], U2: [190055], V0: [190073], V1: [], V2: [190018], W0: [190026], W1: [190058], X0: [190088, 190080, 190012], X1: [190028], X2: [190043, 190064, 190020], Y0: [190083, 190007, 190099], Y1: [190065, 190050], Y2: [190033], Z0: [190051], Z1: [190005, 190038]}"
  },
  {
    "objectID": "docs/tutorials/student_allocation.html#analysis",
    "href": "docs/tutorials/student_allocation.html#analysis",
    "title": "Producing a final-year project allocation",
    "section": "Analysis",
    "text": "Analysis\nThe raw matching provided above is less than easy to read, let alone interpret. So, let’s observe the data in a different form using some visualisation tools.\n\nfrom collections import Counter, defaultdict\nimport matplotlib.pyplot as plt\n\nplt.style.use(\"tableau-colorblind10\")\n%matplotlib inline\n\n\nSupervisors\nUsing the matching.Game instance we’ve created, we can extract the utilisation of our supervisors.\n\nsupervisor_free_spaces = {\n    supervisor: supervisor.capacity - len(supervisor.matching)\n    for supervisor in game.supervisors\n}\n\nsupervisor_utilisation = {\n    supervisor: len(supervisor.matching) / supervisor.capacity\n    for supervisor in game.supervisors\n}\n\n\nfig, ax = plt.subplots(figsize=(8, 4), dpi=300)\n\ndata = Counter(supervisor_free_spaces.values())\nax.bar(data.keys(), data.values())\n\nax.set_xlabel(\"No. free spaces\")\nax.set_ylabel(\"Frequency\")\nax.set_xticks(range(max(data.keys()) + 1))\nax.set_title(\"Supervisor free spaces\")\n\nText(0.5, 1.0, 'Supervisor free spaces')\n\n\n\n\n\n\nfig, ax = plt.subplots(figsize=(8, 4), dpi=300)\n\nvalues = supervisor_utilisation.values()\nax.hist(values)\n\nylims = ax.get_ylim()\nax.vlines(\n    np.mean(list(values)), *ylims, \"tab:orange\", \"dashed\", label=\"Mean\", lw=3\n)\nax.set_ylim(*ylims)\n\nax.set_xlabel(\"Utilisation\")\nax.set_ylabel(\"Frequency\")\nax.set_title(\"Supervisor utilisation\")\nax.legend()\n\n&lt;matplotlib.legend.Legend at 0x7fda4126fca0&gt;\n\n\n\n\n\nSo we can see that the supervisors are almost all working at capacity. This is a good thing so long as they accurately estimated their own workloads.\n\n\nProjects\nWe can do the same visualisation with the projects that were included in the game. This is a nice way to observe the quantity of excess projects offered to students.\n\nproject_free_spaces = {\n    project.name: project.capacity - len(project.matching)\n    for project in game.projects\n}\n\nproject_utilisation = {\n    project.name: len(project.matching) / project.capacity\n    for project in game.projects\n}\n\n\nfig, ax = plt.subplots(figsize=(8, 4), dpi=300)\n\ndata = Counter(project_free_spaces.values())\nax.bar(data.keys(), data.values())\n\nax.set_xlabel(\"No. free spaces\")\nax.set_ylabel(\"Frequency\")\nax.set_xticks(range(max(data.keys()) + 1))\nax.set_title(\"Project free spaces\")\n\nText(0.5, 1.0, 'Project free spaces')\n\n\n\n\n\n\nfig, ax = plt.subplots(figsize=(8, 4), dpi=300)\n\nvalues = project_utilisation.values()\nax.hist(values)\n\nylims = ax.get_ylim()\nax.vlines(\n    np.mean(list(values)), *ylims, \"tab:orange\", \"dashed\", label=\"Mean\", lw=3\n)\nax.set_ylim(*ylims)\n\nax.set_xlabel(\"Utilisation\")\nax.set_ylabel(\"Frequency\")\nax.set_title(\"Project utilisation\")\nax.legend()\n\n&lt;matplotlib.legend.Legend at 0x7fda715f64f0&gt;\n\n\n\n\n\nThe conclusion to draw from this is that the majority of projects seem to be split between two groups:\n\nvery popular (and busy) projects\nvery unpopular (and are excessive) projects\n\nResults like this would help indicate where more projects should be offered in later years.\n\n\nStudents\nArguably, the most valuable analysis is of the students and their matchings. To do this, we will need to “invert” the matching found by Matching.\n\ninverted_matching = {}\nstudent_preference_of_matching = []\nfor project, project_students in matching.items():\n    for student in project_students:\n        inverted_matching[student.name] = project.name\n        student_preference_of_matching.append(\n            student._pref_names.index(project.name)\n        )\n\nThis inverted matching can now be converted to a pandas.DataFrame. In this form, it is easy to link students between the matching data and the original as well as being able to extract those students who remain unmatched.\n\ndf_matching = pd.DataFrame(\n    {\n        \"name\": list(inverted_matching.keys()),\n        \"project_code\": list(inverted_matching.values()),\n        \"preference\": student_preference_of_matching,\n    }\n)\n\ndf_matching = df_matching.sort_values(by=\"name\").reset_index(drop=True)\n\nname_indexed_df_matching = df_matching.set_index(\"name\")\nname_indexed_raw_students = raw_students.set_index(\"name\")\n\ndf_matching = pd.concat(\n    (name_indexed_df_matching, name_indexed_raw_students[\"rank\"]), axis=1\n).reset_index()\n\n\nunassigned_students = df_matching[df_matching[\"preference\"].isnull()]\n\nunassigned_students\n\n\n\n\n\n\n\n\nname\nproject_code\npreference\nrank\n\n\n\n\n93\n190025\nNaN\nNaN\n89\n\n\n94\n190029\nNaN\nNaN\n97\n\n\n95\n190035\nNaN\nNaN\n99\n\n\n96\n190040\nNaN\nNaN\n98\n\n\n97\n190041\nNaN\nNaN\n72\n\n\n98\n190082\nNaN\nNaN\n82\n\n\n99\n190087\nNaN\nNaN\n65\n\n\n\n\n\n\n\n\nassigned_students = df_matching[df_matching[\"preference\"].notnull()]\nassigned_students = assigned_students.astype({\"preference\": int})\nassigned_students.head()\n\n\n\n\n\n\n\n\nname\nproject_code\npreference\nrank\n\n\n\n\n0\n190000\nG2\n0\n3\n\n\n1\n190001\nQ0\n0\n56\n\n\n2\n190002\nU0\n1\n60\n\n\n3\n190003\nC0\n0\n67\n\n\n4\n190004\nI0\n0\n19\n\n\n\n\n\n\n\nNow the data from the matching we’ve found is more manageable, we can try to understand how “good” it is.\nBelow is a bar chart showing the frequency of the students’ preference over their match.\n\nfig, ax = plt.subplots(figsize=(8, 4), dpi=300)\n\nvalues = Counter(assigned_students[\"preference\"])\nax.bar(values.keys(), values.values())\nax.bar(-1.5, len(unassigned_students))\n\nax.set_xticks([-1.5] + list(range(0, 10, 2)))\nax.set_xticklabels([\"Unmatched\"] + list(range(0, 10, 2)))\nax.set_xlabel(\"Preference\")\nax.set_ylabel(\"Frequency\")\nax.set_title(\"Student matching preferences\")\n\nText(0.5, 1.0, 'Student matching preferences')\n\n\n\n\n\nWe can see that the vast majority of students got their first or second choice which is great news.\nAnother thing we should consider is how appropriate the ranking is. Ideally, a student who ranks amongst the best in the cohort should get one of their first choices, and as the rank of the students go down, as should their preference of their match (on average, anyway).\nBelow is a scatter plot of student’s rank and their preference of the project they were allocated.\n\nfig, ax = plt.subplots(figsize=(8, 4), dpi=300)\n\nax.scatter(\n    assigned_students[\"rank\"],\n    assigned_students[\"preference\"],\n    marker=\".\",\n    label=\"matched students\",\n)\n\nax.scatter(\n    unassigned_students[\"rank\"],\n    [-0.5] * len(unassigned_students),\n    marker=\"|\",\n    lw=3,\n    label=\"unmatched students\",\n)\n\nax.set_xlabel(\"Student rank\")\nax.set_ylabel(\"Preference of matching\")\nax.set_title(\"Student rank vs. their preference of their matching\")\nax.legend()\n\n&lt;matplotlib.legend.Legend at 0x7fda20a271c0&gt;\n\n\n\n\n\nThis is the kind of behaviour we want to see. There is a strong line along the bottom, as expected. Then, the cloud of less-preferable matches only grows towards the bottom of the ranking."
  },
  {
    "objectID": "docs/tutorials/student_allocation.html#figuring-out-the-remaining-spaces",
    "href": "docs/tutorials/student_allocation.html#figuring-out-the-remaining-spaces",
    "title": "Producing a final-year project allocation",
    "section": "Figuring out the remaining spaces",
    "text": "Figuring out the remaining spaces\nAlas, this is only a starting point. From here, adjustments can be made to the allocation – although this is not recommended as this could break its mathematical soundness.\nOne avenue to take would be to offer the unassigned students a project with space left over. To figure out where there are spaces, we can use the StudentAllocation object and the data we cleaned earlier.\n\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\n\n\nproject_with_space_names = [\n    project.name\n    for project in game.projects\n    if len(project.matching) &lt; project.capacity\n] + list(unranked_projects)\n\nsupervisor_with_space_names = [\n    supervisor.name\n    for supervisor in game.supervisors\n    if len(supervisor.matching) &lt; supervisor.capacity\n] + list(unranked_supervisors)\n\n\ndef get_number_of_matches(name, party, game):\n    for player in vars(game)[party]:\n        if player.name == name:\n            return len(player.matching)\n\n    return 0\n\n\ndef get_capacity(data, party, name):\n    if party == \"project\":\n        column = \"code\"\n    else:\n        column = \"name\"\n\n    return data[data[column] == name][\"capacity\"].iloc[0]\n\n\nprojects_with_space = projects[\n    (projects[\"code\"].isin(project_with_space_names))\n    & (projects[\"supervisor\"].isin(supervisor_with_space_names))\n]\n\n\nprojects_with_space[\"supervisor_capacity\"] = projects_with_space[\n    \"supervisor\"\n].apply(lambda x: get_capacity(supervisors, \"supervisor\", x))\n\nprojects_with_space[\"project_matches\"] = projects_with_space[\"code\"].apply(\n    lambda x: get_number_of_matches(x, \"projects\", game)\n)\n\nprojects_with_space[\"supervisor_matches\"] = projects_with_space[\n    \"supervisor\"\n].apply(lambda x: get_number_of_matches(x, \"supervisors\", game))\n\nprojects_with_space = projects_with_space[\n    [\n        \"code\",\n        \"capacity\",\n        \"project_matches\",\n        \"supervisor\",\n        \"supervisor_capacity\",\n        \"supervisor_matches\",\n    ]\n]\n\n\nprojects_with_space = projects_with_space.set_index(\n    [\"supervisor\", \"code\"]\n).sort_index()\n\nprojects_with_space\n\n\n\n\n\n\n\n\n\ncapacity\nproject_matches\nsupervisor_capacity\nsupervisor_matches\n\n\nsupervisor\ncode\n\n\n\n\n\n\n\n\nC\nC0\n8\n2\n8\n5\n\n\nC2\n4\n2\n8\n5\n\n\nM\nM0\n8\n2\n7\n5\n\n\nZ\nZ0\n5\n1\n5\n3\n\n\n\n\n\n\n\nSo, with that we have completed this tutorial. We have taken raw data and created a strong allocation of projects to students. Not only that, but we have offered some analysis of this data to demonstrate its effectiveness."
  },
  {
    "objectID": "docs/tutorials/stable_marriage.html",
    "href": "docs/tutorials/stable_marriage.html",
    "title": "Pairing up suitors and reviewers",
    "section": "",
    "text": "In this tutorial we will be setting up and solving an instance of SM.\nIn particular, we will be using an example adapted from the great literary work, Pride and Prejudice (Austen 1813), where four women (Charlotte, Elizabeth, Jane and Lydia) are being courted by four male suitors (Bingley, Collins, Darcy, and Wickham).\nFrom here on out, we’ll refer to the men and women as suitors and reviewers, respectively."
  },
  {
    "objectID": "docs/tutorials/stable_marriage.html#creating-the-players-and-their-preferences",
    "href": "docs/tutorials/stable_marriage.html#creating-the-players-and-their-preferences",
    "title": "Pairing up suitors and reviewers",
    "section": "Creating the players and their preferences",
    "text": "Creating the players and their preferences\nTo begin, we create an instance of the Player class for each suitor and reviewer:\n\nfrom matching import Player\n\nsuitors = [\n    Player(\"Bingley\"),\n    Player(\"Collins\"),\n    Player(\"Darcy\"),\n    Player(\"Wickham\"),\n]\n\nreviewers = [\n    Player(\"Charlotte\"),\n    Player(\"Elizabeth\"),\n    Player(\"Jane\"),\n    Player(\"Lydia\"),\n]\n\nTo set a player’s preferences, we use the Player.set_prefs() method.\nEach player’s preferences must be a list of all the Player instances in the other party ordered according to how much they like them. That is, put your favourite first, followed by your second, and so on until you’ve put your least favourite last.\n\n\n\n\n\n\nWarning\n\n\n\nThe preference lists below are based on some very loose interpretations of the original text and the need to create full lists. Please do not come for me about them.\n\n\nA nice way to do this is by unpacking suitors and reviewers:\n\nbingley, collins, darcy, wickham = suitors\ncharlotte, elizabeth, jane, lydia = reviewers\n\nbingley.set_prefs([jane, elizabeth, lydia, charlotte])\ncollins.set_prefs([elizabeth, jane, lydia, charlotte])\ndarcy.set_prefs([elizabeth, jane, charlotte, lydia])\nwickham.set_prefs([lydia, jane, elizabeth, charlotte])\n\ncharlotte.set_prefs([collins, darcy, bingley, wickham])\nelizabeth.set_prefs([wickham, darcy, bingley, collins])\njane.set_prefs([bingley, wickham, darcy, collins])\nlydia.set_prefs([wickham, bingley, darcy, collins])"
  },
  {
    "objectID": "docs/tutorials/stable_marriage.html#running-the-game",
    "href": "docs/tutorials/stable_marriage.html#running-the-game",
    "title": "Pairing up suitors and reviewers",
    "section": "Running the game",
    "text": "Running the game\nWith our now complete Player instances, we pass the lists of players to the StableMarriage class to create a game:\n\nfrom matching.games import StableMarriage\n\ngame = StableMarriage(suitors, reviewers)\n\nThen we can find a suitor-optimal, stable matching using the solve method:\n\ngame.solve()\n\n{Bingley: Jane, Collins: Charlotte, Darcy: Elizabeth, Wickham: Lydia}\n\n\nHuzzah! We have shown (with some inventive but necessary subtext) that Jane Austen successfully created a stable matching between her characters over a century before the maths had been figured out."
  },
  {
    "objectID": "docs/tutorials/index.html",
    "href": "docs/tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "In these tutorials, we walk through creating and solving various games with the matching package.\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nAllocating university medics to hospital placements\n\n\n\n\n\nIdentify a resident-optimal matching in a simulated South Wales\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nFinding pairs of roommates\n\n\n\n\n\nTry splitting up this funny bunch in the Big Apple\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nPairing up suitors and reviewers\n\n\n\n\n\nHelp our ensemble overcome their pride and prejudice… with maths\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nProducing a final-year project allocation\n\n\n\n\n\nAssign a cohort of students their dissertations according to their grade\n\n\n\n\n \n\n\n\n\nNo matching items"
  },
  {
    "objectID": "docs/discussion/stable_roommates.html",
    "href": "docs/discussion/stable_roommates.html",
    "title": "The stable roommates problem",
    "section": "",
    "text": "The stable roommates problem (SR) describes the problem of finding a stable matching of pairs from one even-sized set of players, all of whom have a complete preference of the remaining players.\n\n\n\n\nConsider a set of \\(N\\) players \\(P\\) where \\(N\\) is even. Each player in \\(P\\) has a ranking of all other players in \\(P\\), and we call this ranking their preference list.\nWe can consider the preference lists of each player as a function which produces tuples. We denote this function as \\(f\\) where:\n\\[f : P \\to P^{N-1}\\]\nThis construction of players and their preference lists is called a game of size \\(N\\), and is denoted by \\(P\\). This game is used to model instances of SR.\n\n\n\nA matching \\(M\\) is any pairing of the elements of \\(P\\). If a pair \\((p,q) \\in P \\times P\\) are matched in \\(M\\), then we say that \\(M(p) = q\\) and, equivalently, \\(M(q) = p\\).\nA matching is only considered valid if all players in \\(P\\) are uniquely matched with exactly one other player.\n\n\n\nA pair \\((p,q)\\) is said to block a matching \\(M\\) if all of the following hold:\n\n\nBoth \\(p\\) and \\(q\\) have a match in \\(M\\).\n\\(p\\) prefers \\(q\\) to \\(M(p) = q'\\).\n\\(q\\) prefers \\(p\\) to \\(M(q) = p'\\).\n\n\nThe notions of preference and stability here are the same as in SM.\n\n\n\n\nConsider the instance of SR below. Here there are six people looking to bunk together on a school trip - Alex, Bowie, Carter, Dallas, Evelyn and Finn. Their preferences of one another are described in the graph below:\n\n\n\nimage\n\n\nIn this representation, a valid matching \\(M\\) creates a 1-regular graph. Again, this graphical representation makes it easy to see the current relationships between the players. Consider the matching below:\n\n\n\nimage\n\n\nHere we can see that players \\(C\\) and \\(F\\) would rather be matched to one another than their current matches, \\(D\\) and \\(E\\) respectively. Thus, \\((C, F)\\) are a blocking pair in this matching and the matching is unstable. We can attempt to rectify this instability by swapping these pairs over:\n\n\n\nimage\n\n\nDespite this move actually making \\(D\\) worse off, there are no players they envy where the feeling is reciprocated under this matching. With that, there are no blocking pairs and this matching is stable.\n\n\n\nRobert Irving presented an efficient, two-phase algorithm for finding a stable matching to SR in Irv85, if one exists. An extended form of the algorithm was presented in GI89, and is given below.\n\n\nThe first phase of the algorithm consists of one-way proposals (we still refer to these as matches here) and removes unpreferable pairs from the game. Begin by assigning all players to be unmatched and without any proposals. Then, while there is a player, \\(p\\), who does not have a held proposal and has a non-empty preference list, do the following:\n\nConsider the favourite player of \\(p\\) and call them \\(q\\).\nIf \\(q\\) is presently holding a proposal from (i.e. is matched to) another player, \\(p'\\), drop the proposal. Let \\(p\\) propose to \\(q\\) so that \\(M(q) = p\\).\nFor each successor, \\(s\\), to \\(p\\) in the preference list of \\(q\\), delete the pair \\((s, q)\\) from the game.\n\nThis phase of the algorithm will terminate either with every player holding a proposal from one other player, or with exactly one player having an empty preference list. The latter case occurs when an individual has been rejected by every other player (during Step 2) and indicates that no stable matching exists. In the case of the former, the second phase can be carried out so long as there exists at least one player with a preference list containing more than one element.\n\n\n\nThe second phase finds and removes all of the all-or-nothing cycles (rotations) from the game. An all-or-nothing cycle represents a series of matches that would immediately result in a blocking pair being formed, hence their removal.\nAn all-or-nothing cycle is a chain of players where the links in the chain alternate between a player's second choice and that player's worst choice. Once a player has appeared twice as the worst choice for some player(s), a cycle has been found. All cycles begin by taking any player in the game with a second choice in their preference list as the first worst choice.\nBased on an all-or-nothing cycle \\((x_1, y_1), \\ldots, (x_n, y_n)\\), for each \\(i = 1, \\ldots, n\\), one must delete from the game all pairs \\((y_i, z)\\) such that \\(y_i\\) prefers \\(x_{i-1}\\) to \\(z\\) where subscripts are taken modulo \\(n\\).\nThis is an important point that is omitted from the original paper, but may be found in GI89.\nThe essential difference between this statement and that in Irv85 is the removal of unpreferable pairs, identified using an all-or-nothing cycle, in addition to those contained in the cycle. Without doing so, tails of cycles can be removed rather than whole cycles, leaving some conflicting pairs in the game.\nAt the end of this phase, each player has at most one player in their preference list. Matching each player to the player in the their preference list will result in a stable matching. If any player has an empty list, then no stable matching exists for the game."
  },
  {
    "objectID": "docs/discussion/stable_roommates.html#key-definitions",
    "href": "docs/discussion/stable_roommates.html#key-definitions",
    "title": "The stable roommates problem",
    "section": "",
    "text": "Consider a set of \\(N\\) players \\(P\\) where \\(N\\) is even. Each player in \\(P\\) has a ranking of all other players in \\(P\\), and we call this ranking their preference list.\nWe can consider the preference lists of each player as a function which produces tuples. We denote this function as \\(f\\) where:\n\\[f : P \\to P^{N-1}\\]\nThis construction of players and their preference lists is called a game of size \\(N\\), and is denoted by \\(P\\). This game is used to model instances of SR.\n\n\n\nA matching \\(M\\) is any pairing of the elements of \\(P\\). If a pair \\((p,q) \\in P \\times P\\) are matched in \\(M\\), then we say that \\(M(p) = q\\) and, equivalently, \\(M(q) = p\\).\nA matching is only considered valid if all players in \\(P\\) are uniquely matched with exactly one other player.\n\n\n\nA pair \\((p,q)\\) is said to block a matching \\(M\\) if all of the following hold:\n\n\nBoth \\(p\\) and \\(q\\) have a match in \\(M\\).\n\\(p\\) prefers \\(q\\) to \\(M(p) = q'\\).\n\\(q\\) prefers \\(p\\) to \\(M(q) = p'\\).\n\n\nThe notions of preference and stability here are the same as in SM."
  },
  {
    "objectID": "docs/discussion/stable_roommates.html#an-example",
    "href": "docs/discussion/stable_roommates.html#an-example",
    "title": "The stable roommates problem",
    "section": "",
    "text": "Consider the instance of SR below. Here there are six people looking to bunk together on a school trip - Alex, Bowie, Carter, Dallas, Evelyn and Finn. Their preferences of one another are described in the graph below:\n\n\n\nimage\n\n\nIn this representation, a valid matching \\(M\\) creates a 1-regular graph. Again, this graphical representation makes it easy to see the current relationships between the players. Consider the matching below:\n\n\n\nimage\n\n\nHere we can see that players \\(C\\) and \\(F\\) would rather be matched to one another than their current matches, \\(D\\) and \\(E\\) respectively. Thus, \\((C, F)\\) are a blocking pair in this matching and the matching is unstable. We can attempt to rectify this instability by swapping these pairs over:\n\n\n\nimage\n\n\nDespite this move actually making \\(D\\) worse off, there are no players they envy where the feeling is reciprocated under this matching. With that, there are no blocking pairs and this matching is stable."
  },
  {
    "objectID": "docs/discussion/stable_roommates.html#the-algorithm",
    "href": "docs/discussion/stable_roommates.html#the-algorithm",
    "title": "The stable roommates problem",
    "section": "",
    "text": "Robert Irving presented an efficient, two-phase algorithm for finding a stable matching to SR in Irv85, if one exists. An extended form of the algorithm was presented in GI89, and is given below.\n\n\nThe first phase of the algorithm consists of one-way proposals (we still refer to these as matches here) and removes unpreferable pairs from the game. Begin by assigning all players to be unmatched and without any proposals. Then, while there is a player, \\(p\\), who does not have a held proposal and has a non-empty preference list, do the following:\n\nConsider the favourite player of \\(p\\) and call them \\(q\\).\nIf \\(q\\) is presently holding a proposal from (i.e. is matched to) another player, \\(p'\\), drop the proposal. Let \\(p\\) propose to \\(q\\) so that \\(M(q) = p\\).\nFor each successor, \\(s\\), to \\(p\\) in the preference list of \\(q\\), delete the pair \\((s, q)\\) from the game.\n\nThis phase of the algorithm will terminate either with every player holding a proposal from one other player, or with exactly one player having an empty preference list. The latter case occurs when an individual has been rejected by every other player (during Step 2) and indicates that no stable matching exists. In the case of the former, the second phase can be carried out so long as there exists at least one player with a preference list containing more than one element.\n\n\n\nThe second phase finds and removes all of the all-or-nothing cycles (rotations) from the game. An all-or-nothing cycle represents a series of matches that would immediately result in a blocking pair being formed, hence their removal.\nAn all-or-nothing cycle is a chain of players where the links in the chain alternate between a player's second choice and that player's worst choice. Once a player has appeared twice as the worst choice for some player(s), a cycle has been found. All cycles begin by taking any player in the game with a second choice in their preference list as the first worst choice.\nBased on an all-or-nothing cycle \\((x_1, y_1), \\ldots, (x_n, y_n)\\), for each \\(i = 1, \\ldots, n\\), one must delete from the game all pairs \\((y_i, z)\\) such that \\(y_i\\) prefers \\(x_{i-1}\\) to \\(z\\) where subscripts are taken modulo \\(n\\).\nThis is an important point that is omitted from the original paper, but may be found in GI89.\nThe essential difference between this statement and that in Irv85 is the removal of unpreferable pairs, identified using an all-or-nothing cycle, in addition to those contained in the cycle. Without doing so, tails of cycles can be removed rather than whole cycles, leaving some conflicting pairs in the game.\nAt the end of this phase, each player has at most one player in their preference list. Matching each player to the player in the their preference list will result in a stable matching. If any player has an empty list, then no stable matching exists for the game."
  },
  {
    "objectID": "docs/discussion/stable_marriage.html",
    "href": "docs/discussion/stable_marriage.html",
    "title": "The stable marriage problem",
    "section": "",
    "text": "The stable marriage problem (SM) describes the problem of finding a stable matching between two distinct, equally sized sets of players with complete preferences.\n\n\n\n\nConsider two distinct sets, \\(S\\) and \\(R\\), each of size \\(N\\), and let us refer to these sets as suitors and reviewers respectively. Each element of \\(S\\) and \\(R\\) has a ranking of all the other set’s elements associated with it, and we call this ranking their preference list.\nWe can consider the preference lists for the elements of each set as a function which produces tuples. We call these functions \\(f\\) and \\(g\\) respectively:\n\\[f : S \\to R^N; \\quad g : R \\to S^N\\]\nThis construction of suitors, reviewers and preference lists is called a game of size \\(N\\), and is denoted by \\((S,R)\\). This game is used to model instances of SM.\n\n\n\nA matching \\(M\\) is any bijection between \\(S\\) and \\(R\\). If a pair \\((s,r) \\in S \\times R\\) are matched in \\(M\\), then we say that \\(M(s) = r\\) and, equivalently, \\(M^{−1}(r) = s\\).\n\n\n\nLet \\((S, R)\\) be an instance of SM. Consider \\(s \\in S\\) and \\(r, r' \\in R\\). We say that \\(s\\) prefers \\(r\\) to \\(r'\\) if \\(r\\) appears before \\(r'\\) in \\(f(s)\\). The definition is equivalent for reviewers.\n\n\n\nA pair \\((s,r)\\) is said to block a matching \\(M\\) if all of the following hold:\n\n\\(s\\) and \\(r\\) aren’t matched by \\(M\\), i.e. \\(M(s) \\neq r\\).\n\\(s\\) prefers \\(r\\) to \\(M(s) = r'\\).\n\\(r\\) prefers \\(s\\) to \\(M^{-1}(r) = s′\\).\n\n\n\n\nA matching \\(M\\) is said to be stable if it contains no blocking pairs, and unstable otherwise.\n\n\n\n\nConsider the unsolved matching game of size three shown below as an edgeless graph with suitors on the left and reviewers on the right. Beside each vertex is the name of the player and their associated ranking of the complementary set’s elements:\n\n\n\nimage\n\n\nIn this representation, a matching \\(M\\) creates a bipartite graph where an edge between two vertices (players) indicates that they are matched by \\(M\\). Consider the matching shown below:\n\n\n\nimage\n\n\nHere we can see that players \\(A\\), \\(C\\) and \\(F\\) are matched to their favourite player but \\(B\\), \\(D\\) and \\(E\\) are matched to their least favourite. There’s nothing particularly special about that but we can see that players \\(B\\) and \\(D\\) form a blocking pair given that they would both rather be matched with one another than with their current match. Hence, this matching is unstable.\nWe can attempt to rectify this instability by swapping the matches for the first two rows:\n\n\n\nimage\n\n\nUpon closer inspection, we can see that each suitor is now matched with their most preferred reviewer so as not to form a blocking pair that would upset any current matchings. This matching is stable and is considered suitor-optimal.\n\n\n\nDavid Gale and Lloyd Shapley presented an algorithm for solving SM in Gale and Shapley (1962). The algorithm provides a unique, stable, suitor-optimal matching for any instance of SM. A more efficient, robust extension of the original algorithm, taken from Gusfield and Irving (1989), is given below.\n\nAssign all suitors and reviewers to be unmatched.\nTake any suitor \\(s\\) that is not currently matched, and consider their favourite reviewer \\(r\\).\nIf \\(r\\) is matched, get their current match \\(s' = M^{-1}(r)\\) and unmatch the pair.\nMatch \\(s\\) and \\(r\\), i.e. set \\(M(s) = r\\).\nFor each successor, \\(t\\), to \\(s\\) in \\(g(r)\\), delete the pair \\((t, r)\\) from the game by removing \\(r\\) from \\(f(t)\\) and \\(t\\) from \\(g(r)\\).\nGo to 1 until there are no such suitors, then end.\n\n\n\n\n\n\n\nReviewer-optimal algorithm\n\n\n\nAs the game requires equally sized sets of players, the reviewer-optimal algorithm is equivalent to the above but with the roles of suitors and reviewers reversed."
  },
  {
    "objectID": "docs/discussion/stable_marriage.html#key-definitions",
    "href": "docs/discussion/stable_marriage.html#key-definitions",
    "title": "The stable marriage problem",
    "section": "",
    "text": "Consider two distinct sets, \\(S\\) and \\(R\\), each of size \\(N\\), and let us refer to these sets as suitors and reviewers respectively. Each element of \\(S\\) and \\(R\\) has a ranking of all the other set’s elements associated with it, and we call this ranking their preference list.\nWe can consider the preference lists for the elements of each set as a function which produces tuples. We call these functions \\(f\\) and \\(g\\) respectively:\n\\[f : S \\to R^N; \\quad g : R \\to S^N\\]\nThis construction of suitors, reviewers and preference lists is called a game of size \\(N\\), and is denoted by \\((S,R)\\). This game is used to model instances of SM.\n\n\n\nA matching \\(M\\) is any bijection between \\(S\\) and \\(R\\). If a pair \\((s,r) \\in S \\times R\\) are matched in \\(M\\), then we say that \\(M(s) = r\\) and, equivalently, \\(M^{−1}(r) = s\\).\n\n\n\nLet \\((S, R)\\) be an instance of SM. Consider \\(s \\in S\\) and \\(r, r' \\in R\\). We say that \\(s\\) prefers \\(r\\) to \\(r'\\) if \\(r\\) appears before \\(r'\\) in \\(f(s)\\). The definition is equivalent for reviewers.\n\n\n\nA pair \\((s,r)\\) is said to block a matching \\(M\\) if all of the following hold:\n\n\\(s\\) and \\(r\\) aren’t matched by \\(M\\), i.e. \\(M(s) \\neq r\\).\n\\(s\\) prefers \\(r\\) to \\(M(s) = r'\\).\n\\(r\\) prefers \\(s\\) to \\(M^{-1}(r) = s′\\).\n\n\n\n\nA matching \\(M\\) is said to be stable if it contains no blocking pairs, and unstable otherwise."
  },
  {
    "objectID": "docs/discussion/stable_marriage.html#an-example",
    "href": "docs/discussion/stable_marriage.html#an-example",
    "title": "The stable marriage problem",
    "section": "",
    "text": "Consider the unsolved matching game of size three shown below as an edgeless graph with suitors on the left and reviewers on the right. Beside each vertex is the name of the player and their associated ranking of the complementary set’s elements:\n\n\n\nimage\n\n\nIn this representation, a matching \\(M\\) creates a bipartite graph where an edge between two vertices (players) indicates that they are matched by \\(M\\). Consider the matching shown below:\n\n\n\nimage\n\n\nHere we can see that players \\(A\\), \\(C\\) and \\(F\\) are matched to their favourite player but \\(B\\), \\(D\\) and \\(E\\) are matched to their least favourite. There’s nothing particularly special about that but we can see that players \\(B\\) and \\(D\\) form a blocking pair given that they would both rather be matched with one another than with their current match. Hence, this matching is unstable.\nWe can attempt to rectify this instability by swapping the matches for the first two rows:\n\n\n\nimage\n\n\nUpon closer inspection, we can see that each suitor is now matched with their most preferred reviewer so as not to form a blocking pair that would upset any current matchings. This matching is stable and is considered suitor-optimal."
  },
  {
    "objectID": "docs/discussion/stable_marriage.html#the-algorithm",
    "href": "docs/discussion/stable_marriage.html#the-algorithm",
    "title": "The stable marriage problem",
    "section": "",
    "text": "David Gale and Lloyd Shapley presented an algorithm for solving SM in Gale and Shapley (1962). The algorithm provides a unique, stable, suitor-optimal matching for any instance of SM. A more efficient, robust extension of the original algorithm, taken from Gusfield and Irving (1989), is given below.\n\nAssign all suitors and reviewers to be unmatched.\nTake any suitor \\(s\\) that is not currently matched, and consider their favourite reviewer \\(r\\).\nIf \\(r\\) is matched, get their current match \\(s' = M^{-1}(r)\\) and unmatch the pair.\nMatch \\(s\\) and \\(r\\), i.e. set \\(M(s) = r\\).\nFor each successor, \\(t\\), to \\(s\\) in \\(g(r)\\), delete the pair \\((t, r)\\) from the game by removing \\(r\\) from \\(f(t)\\) and \\(t\\) from \\(g(r)\\).\nGo to 1 until there are no such suitors, then end.\n\n\n\n\n\n\n\nReviewer-optimal algorithm\n\n\n\nAs the game requires equally sized sets of players, the reviewer-optimal algorithm is equivalent to the above but with the roles of suitors and reviewers reversed."
  },
  {
    "objectID": "docs/discussion/hospital_resident.html",
    "href": "docs/discussion/hospital_resident.html",
    "title": "The hospital-resident assignment problem",
    "section": "",
    "text": "The hospital-resident assignment problem (HR) is an extension of SM where residents must be assigned to placements at hospitals.\n\n\n\n\nConsider two distinct sets, \\(R\\) and \\(H\\), and let us refer to them as residents and hospitals. Each hospital \\(h \\in H\\) has a capacity associated with them \\(c_h \\in \\mathbb{N}\\).\nAs in SM, each player has a preference list associated with them but they needn't be exhaustive of the other party. Instead:\n\nEach resident \\(r \\in R\\) must rank a non-empty subset of \\(H\\). We denote this preference by \\(f(r)\\).\nEach hospital \\(h \\in H\\) must rank all those residents that have ranked it. That is, the preference list of \\(h\\), denoted by \\(g(h)\\), is a permutation of the set given by \\(\\left\\{r \\in R \\ | \\ h \\in f(r)\\right\\}\\). If no residents rank a hospital then that hospital is removed from \\(H\\).\n\nThis construction of residents, hospitals, capacities and preference lists is a game and is denoted by \\((R,H)\\). This game is used to model instances of HR.\n\n\n\nA matching \\(M\\) is any mapping between \\(R\\) and \\(H\\). If a pair \\((r, h) \\in R \\times H\\) are matched in \\(M\\), we say that \\(M(r) = h\\) and \\(r \\in M^{-1}(h)\\).\nA matching is only considered valid if all of the following are satisfied:\n\n\nFor all \\(r \\in R\\) with a match we have \\(M(r) \\in f(r)\\).\nFor all \\(h \\in H\\) with matches we have \\(M^{-1}(h) \\subseteq g(h)\\).\nFor all \\(h \\in H\\) we have \\(|M^{-1}(h)| \\leq c_h\\).\n\n\nAgain, a valid matching is considered stable if it does not contain any blocking pairs.\n\n\n\nA pair \\((r, h)\\) is said to block a matching \\(M\\) if all the following hold:\n\n\nThere is mutual preference, i.e. \\(r \\in g(h)\\) and \\(h \\in f(r)\\).\nEither \\(r\\) is unmatched or they prefer \\(h\\) to \\(M(r) = h'\\).\nEither \\(|M^{-1}(h)| &lt; c_h\\) or \\(h\\) prefers \\(r\\) to at least one \\(r' \\in M^{-1}(h)\\).\n\n\nThe notion of preference here is the same as in SM.\n\n\n\n\nConsider the following instance of HR. There are five residents – Ada, Sam, Jo, Luc, Dani – applying to work at three hospitals: Mercy, City, General. Each hospital has two available positions, and the players' preferences of one another are described in the graph below:\n\n\n\nimage\n\n\nAs with SM, this representation is a easy way to keep track of the current state of the problem and the relationships between players. Consider the matching presented below:\n\n\n\nimage\n\n\nThis matching is invalid. In fact, none of the conditions for validity have been met: City hospital is over-subscribed and Ada has been assigned to a hospital that they did not rank (likewise for Mercy). Some slight tinkering can produce a valid matching:\n\n\n\nimage\n\n\nEven with this, the matching is not stable. There exists one blocking pair: \\((L, M)\\). Here, there is mutual preference, Luc prefers Mercy to General and Mercy has a space remaining. Hence, a stable solution would be as follows:\n\n\n\nimage\n\n\nIt also so happens that this matching is both resident- and hospital-optimal.\n\n\n\nFinding optimal, stable matchings for HR is of great importance as it solves real-world problems. For instance, the National Resident Matching Program uses an algorithm like the one presented here to assign medical students in the US to hospitals. An algorithm which solves HR was originally presented in GS62 but further work was done to improve on these algorithms in later years DF81, Rot84. Unlike the algorithm for SM, this algorithm takes a different form depending on the desired optimality of the solution.\nBelow are resident-optimal and hospital-optimal algorithms for finding a unique, stable matching for an instance of HR. Each algorithm was taken from GI89.\n\n\n\nAssign all residents to be unmatched, and all hospitals to be totally unsubscribed.\nTake any unmatched resident with a non-empty preference list \\(r\\), and consider their most preferred hospital \\(h\\). Match them to one another.\nIf \\(|M^{-1}(h)| &gt; c_h\\), find the worst resident \\(r'\\) assigned to \\(h\\) and unmatch the pair \\((r', h)\\).\nIf \\(|M^{-1}(h)| = c_h\\), find the worst resident \\(r'\\) assigned to \\(h\\). Then, for each successor \\(s \\in g(h)\\) to \\(r'\\), delete the pair \\((s, h)\\) from the game by removing \\(h\\) from \\(f(s)\\) and \\(s\\) from \\(g(h)\\).\nGo to 1 until there are no such residents left, then end.\n\n\n\n\n\nSet all residents to be unmatched, and all hospitals to be totally unsubscribed.\nTake any hospital \\(h\\) that is under-subscribed and whose preference list contains any resident they are not currently assigned to, and consider their most preferred such resident \\(r\\).\nIf \\(r\\) is currently matched to some other hospital \\(h'\\), then unmatch them from one another.\nMatch \\(r\\) with \\(h\\).\nFor each successor \\(s \\in f(r)\\) to \\(h\\), delete the pair \\((r, s)\\) from the game.\nGo to 1 until there are no such hospitals left, then end."
  },
  {
    "objectID": "docs/discussion/hospital_resident.html#key-definitions",
    "href": "docs/discussion/hospital_resident.html#key-definitions",
    "title": "The hospital-resident assignment problem",
    "section": "",
    "text": "Consider two distinct sets, \\(R\\) and \\(H\\), and let us refer to them as residents and hospitals. Each hospital \\(h \\in H\\) has a capacity associated with them \\(c_h \\in \\mathbb{N}\\).\nAs in SM, each player has a preference list associated with them but they needn't be exhaustive of the other party. Instead:\n\nEach resident \\(r \\in R\\) must rank a non-empty subset of \\(H\\). We denote this preference by \\(f(r)\\).\nEach hospital \\(h \\in H\\) must rank all those residents that have ranked it. That is, the preference list of \\(h\\), denoted by \\(g(h)\\), is a permutation of the set given by \\(\\left\\{r \\in R \\ | \\ h \\in f(r)\\right\\}\\). If no residents rank a hospital then that hospital is removed from \\(H\\).\n\nThis construction of residents, hospitals, capacities and preference lists is a game and is denoted by \\((R,H)\\). This game is used to model instances of HR.\n\n\n\nA matching \\(M\\) is any mapping between \\(R\\) and \\(H\\). If a pair \\((r, h) \\in R \\times H\\) are matched in \\(M\\), we say that \\(M(r) = h\\) and \\(r \\in M^{-1}(h)\\).\nA matching is only considered valid if all of the following are satisfied:\n\n\nFor all \\(r \\in R\\) with a match we have \\(M(r) \\in f(r)\\).\nFor all \\(h \\in H\\) with matches we have \\(M^{-1}(h) \\subseteq g(h)\\).\nFor all \\(h \\in H\\) we have \\(|M^{-1}(h)| \\leq c_h\\).\n\n\nAgain, a valid matching is considered stable if it does not contain any blocking pairs.\n\n\n\nA pair \\((r, h)\\) is said to block a matching \\(M\\) if all the following hold:\n\n\nThere is mutual preference, i.e. \\(r \\in g(h)\\) and \\(h \\in f(r)\\).\nEither \\(r\\) is unmatched or they prefer \\(h\\) to \\(M(r) = h'\\).\nEither \\(|M^{-1}(h)| &lt; c_h\\) or \\(h\\) prefers \\(r\\) to at least one \\(r' \\in M^{-1}(h)\\).\n\n\nThe notion of preference here is the same as in SM."
  },
  {
    "objectID": "docs/discussion/hospital_resident.html#an-example",
    "href": "docs/discussion/hospital_resident.html#an-example",
    "title": "The hospital-resident assignment problem",
    "section": "",
    "text": "Consider the following instance of HR. There are five residents – Ada, Sam, Jo, Luc, Dani – applying to work at three hospitals: Mercy, City, General. Each hospital has two available positions, and the players' preferences of one another are described in the graph below:\n\n\n\nimage\n\n\nAs with SM, this representation is a easy way to keep track of the current state of the problem and the relationships between players. Consider the matching presented below:\n\n\n\nimage\n\n\nThis matching is invalid. In fact, none of the conditions for validity have been met: City hospital is over-subscribed and Ada has been assigned to a hospital that they did not rank (likewise for Mercy). Some slight tinkering can produce a valid matching:\n\n\n\nimage\n\n\nEven with this, the matching is not stable. There exists one blocking pair: \\((L, M)\\). Here, there is mutual preference, Luc prefers Mercy to General and Mercy has a space remaining. Hence, a stable solution would be as follows:\n\n\n\nimage\n\n\nIt also so happens that this matching is both resident- and hospital-optimal."
  },
  {
    "objectID": "docs/discussion/hospital_resident.html#the-algorithm",
    "href": "docs/discussion/hospital_resident.html#the-algorithm",
    "title": "The hospital-resident assignment problem",
    "section": "",
    "text": "Finding optimal, stable matchings for HR is of great importance as it solves real-world problems. For instance, the National Resident Matching Program uses an algorithm like the one presented here to assign medical students in the US to hospitals. An algorithm which solves HR was originally presented in GS62 but further work was done to improve on these algorithms in later years DF81, Rot84. Unlike the algorithm for SM, this algorithm takes a different form depending on the desired optimality of the solution.\nBelow are resident-optimal and hospital-optimal algorithms for finding a unique, stable matching for an instance of HR. Each algorithm was taken from GI89.\n\n\n\nAssign all residents to be unmatched, and all hospitals to be totally unsubscribed.\nTake any unmatched resident with a non-empty preference list \\(r\\), and consider their most preferred hospital \\(h\\). Match them to one another.\nIf \\(|M^{-1}(h)| &gt; c_h\\), find the worst resident \\(r'\\) assigned to \\(h\\) and unmatch the pair \\((r', h)\\).\nIf \\(|M^{-1}(h)| = c_h\\), find the worst resident \\(r'\\) assigned to \\(h\\). Then, for each successor \\(s \\in g(h)\\) to \\(r'\\), delete the pair \\((s, h)\\) from the game by removing \\(h\\) from \\(f(s)\\) and \\(s\\) from \\(g(h)\\).\nGo to 1 until there are no such residents left, then end.\n\n\n\n\n\nSet all residents to be unmatched, and all hospitals to be totally unsubscribed.\nTake any hospital \\(h\\) that is under-subscribed and whose preference list contains any resident they are not currently assigned to, and consider their most preferred such resident \\(r\\).\nIf \\(r\\) is currently matched to some other hospital \\(h'\\), then unmatch them from one another.\nMatch \\(r\\) with \\(h\\).\nFor each successor \\(s \\in f(r)\\) to \\(h\\), delete the pair \\((r, s)\\) from the game.\nGo to 1 until there are no such hospitals left, then end."
  },
  {
    "objectID": "docs/reference/Hospital.html",
    "href": "docs/reference/Hospital.html",
    "title": "Hospital",
    "section": "",
    "text": "players.Hospital(self, name, capacity)\nHospital player class for instances of HR.\nA hospital can take multiple simultaneous matches and has a capacity. The classes for projects and supervisors in SA inherit from this class.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nobject\nAn identifier. This should be unique and descriptive.\nrequired\n\n\ncapacity\nint\nThe maximum number of matches the hospital can have.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprefs\nlist of Player\nThe hospital’s preferences. Defaults to None and is updated using the set_prefs method.\n\n\npref_names\nlist\nA list of the names in prefs. Updates with prefs via the set_prefs method.\n\n\nmatching\nlist of Player\nThe current matches of the hospital. An empty list if currently unsubscribed.\n\n\n_original_capacity\nint\nA record of the player’s original capacity in case it is altered when passed to a game.\n\n\n_original_prefs\nlist of Player\nA record of the player’s original preferences.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_if_match_is_unacceptable\nCheck the acceptability of the current matches.\n\n\ncheck_if_oversubscribed\nCheck whether the player has too many matches.\n\n\nget_favourite\nGet the hospital’s favourite resident outside their matching.\n\n\nget_successors\nGet the successors to the player’s worst current match.\n\n\nget_worst_match\nGet the player’s worst current match.\n\n\noversubscribed_message\nMessage to say the hospital has too many matches.\n\n\n\n\n\nplayers.Hospital.check_if_match_is_unacceptable(self, **kwargs)\nCheck the acceptability of the current matches.\n\n\n\nplayers.Hospital.check_if_oversubscribed(self)\nCheck whether the player has too many matches.\n\n\n\nplayers.Hospital.get_favourite(self)\nGet the hospital’s favourite resident outside their matching.\nIf no such resident exists, return None.\n\n\n\nplayers.Hospital.get_successors(self)\nGet the successors to the player’s worst current match.\n\n\n\nplayers.Hospital.get_worst_match(self)\nGet the player’s worst current match.\nThis method assumes that the hospital’s matching is in order of their preference list.\n\n\n\nplayers.Hospital.oversubscribed_message(self)\nMessage to say the hospital has too many matches."
  },
  {
    "objectID": "docs/reference/Hospital.html#parameters",
    "href": "docs/reference/Hospital.html#parameters",
    "title": "Hospital",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nname\nobject\nAn identifier. This should be unique and descriptive.\nrequired\n\n\ncapacity\nint\nThe maximum number of matches the hospital can have.\nrequired"
  },
  {
    "objectID": "docs/reference/Hospital.html#attributes",
    "href": "docs/reference/Hospital.html#attributes",
    "title": "Hospital",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nprefs\nlist of Player\nThe hospital’s preferences. Defaults to None and is updated using the set_prefs method.\n\n\npref_names\nlist\nA list of the names in prefs. Updates with prefs via the set_prefs method.\n\n\nmatching\nlist of Player\nThe current matches of the hospital. An empty list if currently unsubscribed.\n\n\n_original_capacity\nint\nA record of the player’s original capacity in case it is altered when passed to a game.\n\n\n_original_prefs\nlist of Player\nA record of the player’s original preferences."
  },
  {
    "objectID": "docs/reference/Hospital.html#methods",
    "href": "docs/reference/Hospital.html#methods",
    "title": "Hospital",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_if_match_is_unacceptable\nCheck the acceptability of the current matches.\n\n\ncheck_if_oversubscribed\nCheck whether the player has too many matches.\n\n\nget_favourite\nGet the hospital’s favourite resident outside their matching.\n\n\nget_successors\nGet the successors to the player’s worst current match.\n\n\nget_worst_match\nGet the player’s worst current match.\n\n\noversubscribed_message\nMessage to say the hospital has too many matches.\n\n\n\n\n\nplayers.Hospital.check_if_match_is_unacceptable(self, **kwargs)\nCheck the acceptability of the current matches.\n\n\n\nplayers.Hospital.check_if_oversubscribed(self)\nCheck whether the player has too many matches.\n\n\n\nplayers.Hospital.get_favourite(self)\nGet the hospital’s favourite resident outside their matching.\nIf no such resident exists, return None.\n\n\n\nplayers.Hospital.get_successors(self)\nGet the successors to the player’s worst current match.\n\n\n\nplayers.Hospital.get_worst_match(self)\nGet the player’s worst current match.\nThis method assumes that the hospital’s matching is in order of their preference list.\n\n\n\nplayers.Hospital.oversubscribed_message(self)\nMessage to say the hospital has too many matches."
  },
  {
    "objectID": "docs/reference/StableMarriage.html",
    "href": "docs/reference/StableMarriage.html",
    "title": "StableMarriage",
    "section": "",
    "text": "games.StableMarriage(self, suitors, reviewers)\nSolver for the stable marriage problem (SM).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsuitors\nlist of Player\nThe suitors in the game. Each suitor must rank all elements in reviewers.\nrequired\n\n\nreviewers\nlist of Player\nThe reviewers in the game. Each reviewer must rank all elements in suitors.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmatching\nSingleMatching or None\nOnce the game is solved, a matching is available. This uses the suitors and reviewers as keys and values, respectively, in a SingleMatching object. Initialises as None.\n\n\nblocking_pairs\nlist of (Player, Player)\nThe suitor-reviewer pairs that both prefer one another to their current match. Initialises as None.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_inputs\nRaise an error if any of the game’s rules do not hold.\n\n\ncheck_stability\nCheck for the existence of any blocking pairs.\n\n\ncheck_validity\nCheck whether the current matching is valid.\n\n\ncreate_from_dictionaries\nCreate an instance of SM from two preference dictionaries.\n\n\nsolve\nSolve the instance of SM. Return the matching.\n\n\n\n\n\ngames.StableMarriage.check_inputs(self)\nRaise an error if any of the game’s rules do not hold.\n\n\n\ngames.StableMarriage.check_stability(self)\nCheck for the existence of any blocking pairs.\n\n\n\ngames.StableMarriage.check_validity(self)\nCheck whether the current matching is valid.\n\n\n\ngames.StableMarriage.create_from_dictionaries(cls, suitor_prefs, reviewer_prefs)\nCreate an instance of SM from two preference dictionaries.\n\n\n\ngames.StableMarriage.solve(self, optimal='suitor')\nSolve the instance of SM. Return the matching.\nThe party optimality can be controlled using the optimal parameter."
  },
  {
    "objectID": "docs/reference/StableMarriage.html#parameters",
    "href": "docs/reference/StableMarriage.html#parameters",
    "title": "StableMarriage",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsuitors\nlist of Player\nThe suitors in the game. Each suitor must rank all elements in reviewers.\nrequired\n\n\nreviewers\nlist of Player\nThe reviewers in the game. Each reviewer must rank all elements in suitors.\nrequired"
  },
  {
    "objectID": "docs/reference/StableMarriage.html#attributes",
    "href": "docs/reference/StableMarriage.html#attributes",
    "title": "StableMarriage",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nmatching\nSingleMatching or None\nOnce the game is solved, a matching is available. This uses the suitors and reviewers as keys and values, respectively, in a SingleMatching object. Initialises as None.\n\n\nblocking_pairs\nlist of (Player, Player)\nThe suitor-reviewer pairs that both prefer one another to their current match. Initialises as None."
  },
  {
    "objectID": "docs/reference/StableMarriage.html#methods",
    "href": "docs/reference/StableMarriage.html#methods",
    "title": "StableMarriage",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_inputs\nRaise an error if any of the game’s rules do not hold.\n\n\ncheck_stability\nCheck for the existence of any blocking pairs.\n\n\ncheck_validity\nCheck whether the current matching is valid.\n\n\ncreate_from_dictionaries\nCreate an instance of SM from two preference dictionaries.\n\n\nsolve\nSolve the instance of SM. Return the matching.\n\n\n\n\n\ngames.StableMarriage.check_inputs(self)\nRaise an error if any of the game’s rules do not hold.\n\n\n\ngames.StableMarriage.check_stability(self)\nCheck for the existence of any blocking pairs.\n\n\n\ngames.StableMarriage.check_validity(self)\nCheck whether the current matching is valid.\n\n\n\ngames.StableMarriage.create_from_dictionaries(cls, suitor_prefs, reviewer_prefs)\nCreate an instance of SM from two preference dictionaries.\n\n\n\ngames.StableMarriage.solve(self, optimal='suitor')\nSolve the instance of SM. Return the matching.\nThe party optimality can be controlled using the optimal parameter."
  },
  {
    "objectID": "docs/reference/stable_marriage.html",
    "href": "docs/reference/stable_marriage.html",
    "title": "stable_marriage",
    "section": "",
    "text": "algorithms.stable_marriage\nFunctions for the SM algorithms.\n\n\n\n\n\nName\nDescription\n\n\n\n\nstable_marriage\nAn extended version of the original Gale-Shapley algorithm.\n\n\n\n\n\nalgorithms.stable_marriage.stable_marriage(suitors, reviewers, optimal='suitor')\nAn extended version of the original Gale-Shapley algorithm.\nThis version makes use of the inherent structures of SM instances. A unique, stable and optimal matching is found for any valid set of suitors and reviewers. The optimality of the matching is with respect to one party and is subsequently the worst stable matching for the other.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsuitors\nlist of Player\nThe suitors in the game. Each must rank all of those in reviewers.\nrequired\n\n\nreviewers\nlist of Player\nThe reviewers in the game. Each must rank all of those in suitors.\nrequired\n\n\noptimal\nstr\nWhich party the matching should be optimised for. Must be one of \"suitor\" and \"reviewer\". Defaults to the former.\n'suitor'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nMatching\nA dictionary-like object where the keys are given by the members of suitors, and the values are their match in reviewers."
  },
  {
    "objectID": "docs/reference/stable_marriage.html#functions",
    "href": "docs/reference/stable_marriage.html#functions",
    "title": "stable_marriage",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nstable_marriage\nAn extended version of the original Gale-Shapley algorithm.\n\n\n\n\n\nalgorithms.stable_marriage.stable_marriage(suitors, reviewers, optimal='suitor')\nAn extended version of the original Gale-Shapley algorithm.\nThis version makes use of the inherent structures of SM instances. A unique, stable and optimal matching is found for any valid set of suitors and reviewers. The optimality of the matching is with respect to one party and is subsequently the worst stable matching for the other.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsuitors\nlist of Player\nThe suitors in the game. Each must rank all of those in reviewers.\nrequired\n\n\nreviewers\nlist of Player\nThe reviewers in the game. Each must rank all of those in suitors.\nrequired\n\n\noptimal\nstr\nWhich party the matching should be optimised for. Must be one of \"suitor\" and \"reviewer\". Defaults to the former.\n'suitor'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nMatching\nA dictionary-like object where the keys are given by the members of suitors, and the values are their match in reviewers."
  },
  {
    "objectID": "docs/reference/hospital_resident.html",
    "href": "docs/reference/hospital_resident.html",
    "title": "hospital_resident",
    "section": "",
    "text": "algorithms.hospital_resident\nFunctions for the HR algorithms.\n\n\n\n\n\nName\nDescription\n\n\n\n\nhospital_optimal\nSolve the instance of HR to be hospital-optimal.\n\n\nhospital_resident\nSolve an instance of HR using an adapted Gale-Shapley algorithm\n\n\nresident_optimal\nSolve the instance of HR to be resident-optimal.\n\n\n\n\n\nalgorithms.hospital_resident.hospital_optimal(hospitals)\nSolve the instance of HR to be hospital-optimal.\nThe hospital-optimal algorithm is as follows:\n0. Set all residents to be unmatched, and all hospitals to be\n   totally unsubscribed.\n\n1. Take any hospital, :math:`h`, that is under-subscribed and\n   whose preference list contains any resident they are not\n   currently assigned to, and consider their most preferred such\n   resident, :math:`r`.\n\n2. If :math:`r` is currently matched, say to :math:`h'`, then\n   unmatch them from one another. In any case, match :math:`r`\n   to :math:`h` and go to 3.\n\n3. For each successor, :math:`s`, to :math:`h` in the preference\n   list of :math:`r`, delete the pair :math:`(r, s)` from the\n   game.\n\n4. Go to 1 until there are no such hospitals left, then end.\n\n\n\nalgorithms.hospital_resident.hospital_resident(residents, hospitals, optimal='resident')\nSolve an instance of HR using an adapted Gale-Shapley algorithm :cite:Rot84. A unique, stable and optimal matching is found for the given set of residents and hospitals. The optimality of the matching is found with respect to one party and is subsequently the worst stable matching for the other.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nresidents\nlist of Player\nThe residents in the game. Each resident must rank a non-empty subset of the elements of hospitals.\nrequired\n\n\nhospitals\nlist of Hospital\nThe hospitals in the game. Each hospital must rank all the residents that have ranked them.\nrequired\n\n\noptimal\nstr\nWhich party the matching should be optimised for. Must be one of \"resident\" and \"hospital\". Defaults to the former.\n'resident'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nMatching\nA dictionary-like object where the keys are the members of hospitals, and the values are their matches ranked by preference.\n\n\n\n\n\n\n\nalgorithms.hospital_resident.resident_optimal(residents, hospitals)\nSolve the instance of HR to be resident-optimal.\nThe resident-optimal algorithm is as follows:\n0. Set all residents to be unmatched, and all hospitals to be\n   totally unsubscribed.\n\n1. Take any unmatched resident with a non-empty preference list,\n   :math:`r`, and consider their most preferred hospital,\n   :math:`h`. Match them to one another.\n\n2. If, as a result of this new matching, :math:`h` is now\n   over-subscribed, find the worst resident currently assigned\n   to :math:`h`, :math:`r'`. Set :math:`r'` to be unmatched and\n   remove them from :math:`h`'s matching. Otherwise, go to 3.\n\n3. If :math:`h` is at capacity (fully subscribed) then find\n   their worst current match :math:`r'`. Then, for each\n   successor, :math:`s`, to :math:`r'` in the preference list of\n   :math:`h`, delete the pair :math:`(s, h)` from the game.\n   Otherwise, go to 4.\n\n4. Go to 1 until there are no such residents left, then end."
  },
  {
    "objectID": "docs/reference/hospital_resident.html#functions",
    "href": "docs/reference/hospital_resident.html#functions",
    "title": "hospital_resident",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhospital_optimal\nSolve the instance of HR to be hospital-optimal.\n\n\nhospital_resident\nSolve an instance of HR using an adapted Gale-Shapley algorithm\n\n\nresident_optimal\nSolve the instance of HR to be resident-optimal.\n\n\n\n\n\nalgorithms.hospital_resident.hospital_optimal(hospitals)\nSolve the instance of HR to be hospital-optimal.\nThe hospital-optimal algorithm is as follows:\n0. Set all residents to be unmatched, and all hospitals to be\n   totally unsubscribed.\n\n1. Take any hospital, :math:`h`, that is under-subscribed and\n   whose preference list contains any resident they are not\n   currently assigned to, and consider their most preferred such\n   resident, :math:`r`.\n\n2. If :math:`r` is currently matched, say to :math:`h'`, then\n   unmatch them from one another. In any case, match :math:`r`\n   to :math:`h` and go to 3.\n\n3. For each successor, :math:`s`, to :math:`h` in the preference\n   list of :math:`r`, delete the pair :math:`(r, s)` from the\n   game.\n\n4. Go to 1 until there are no such hospitals left, then end.\n\n\n\nalgorithms.hospital_resident.hospital_resident(residents, hospitals, optimal='resident')\nSolve an instance of HR using an adapted Gale-Shapley algorithm :cite:Rot84. A unique, stable and optimal matching is found for the given set of residents and hospitals. The optimality of the matching is found with respect to one party and is subsequently the worst stable matching for the other.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nresidents\nlist of Player\nThe residents in the game. Each resident must rank a non-empty subset of the elements of hospitals.\nrequired\n\n\nhospitals\nlist of Hospital\nThe hospitals in the game. Each hospital must rank all the residents that have ranked them.\nrequired\n\n\noptimal\nstr\nWhich party the matching should be optimised for. Must be one of \"resident\" and \"hospital\". Defaults to the former.\n'resident'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nMatching\nA dictionary-like object where the keys are the members of hospitals, and the values are their matches ranked by preference.\n\n\n\n\n\n\n\nalgorithms.hospital_resident.resident_optimal(residents, hospitals)\nSolve the instance of HR to be resident-optimal.\nThe resident-optimal algorithm is as follows:\n0. Set all residents to be unmatched, and all hospitals to be\n   totally unsubscribed.\n\n1. Take any unmatched resident with a non-empty preference list,\n   :math:`r`, and consider their most preferred hospital,\n   :math:`h`. Match them to one another.\n\n2. If, as a result of this new matching, :math:`h` is now\n   over-subscribed, find the worst resident currently assigned\n   to :math:`h`, :math:`r'`. Set :math:`r'` to be unmatched and\n   remove them from :math:`h`'s matching. Otherwise, go to 3.\n\n3. If :math:`h` is at capacity (fully subscribed) then find\n   their worst current match :math:`r'`. Then, for each\n   successor, :math:`s`, to :math:`r'` in the preference list of\n   :math:`h`, delete the pair :math:`(s, h)` from the game.\n   Otherwise, go to 4.\n\n4. Go to 1 until there are no such residents left, then end."
  },
  {
    "objectID": "docs/reference/Supervisor.html",
    "href": "docs/reference/Supervisor.html",
    "title": "Supervisor",
    "section": "",
    "text": "players.Supervisor(self, name, capacity)\nSupervisor player class for instances of SA.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nobject\nAn identifier. This should be unique and descriptive.\nrequired\n\n\ncapacity\nint\nThe maximum number of matches the supervisor can have.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprojects\nlist of Project\nThe projects that the supervisor runs. Defaults to an empty list.\n\n\nprefs\nlist of Player\nThe supervisor’s preferences. Defaults to None and is updated via the set_prefs method.\n\n\npref_names\nlist\nA list of the names in prefs. Updates with prefs via set_prefs.\n\n\nmatching\nlist of Player\nThe current matches of the supervisor. An empty list if currently unsubscribed, and updated through its projects’ matching updates.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_favourite\nGet the supervisor’s favourite viable student.\n\n\nset_prefs\nSet the preference list for the supervisor.\n\n\n\n\n\nplayers.Supervisor.get_favourite(self)\nGet the supervisor’s favourite viable student.\nA student is viable if they are not currently matched to, but have a preference of, one of the supervisor’s under-subscribed projects. This method also returns the student’s favourite under-subscribed project. If no such student exists, return None.\n\n\n\nplayers.Supervisor.set_prefs(self, students)\nSet the preference list for the supervisor.\nThis method also passes the preferences on to its projects according to those students who ranked each project."
  },
  {
    "objectID": "docs/reference/Supervisor.html#parameters",
    "href": "docs/reference/Supervisor.html#parameters",
    "title": "Supervisor",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nname\nobject\nAn identifier. This should be unique and descriptive.\nrequired\n\n\ncapacity\nint\nThe maximum number of matches the supervisor can have.\nrequired"
  },
  {
    "objectID": "docs/reference/Supervisor.html#attributes",
    "href": "docs/reference/Supervisor.html#attributes",
    "title": "Supervisor",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nprojects\nlist of Project\nThe projects that the supervisor runs. Defaults to an empty list.\n\n\nprefs\nlist of Player\nThe supervisor’s preferences. Defaults to None and is updated via the set_prefs method.\n\n\npref_names\nlist\nA list of the names in prefs. Updates with prefs via set_prefs.\n\n\nmatching\nlist of Player\nThe current matches of the supervisor. An empty list if currently unsubscribed, and updated through its projects’ matching updates."
  },
  {
    "objectID": "docs/reference/Supervisor.html#methods",
    "href": "docs/reference/Supervisor.html#methods",
    "title": "Supervisor",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_favourite\nGet the supervisor’s favourite viable student.\n\n\nset_prefs\nSet the preference list for the supervisor.\n\n\n\n\n\nplayers.Supervisor.get_favourite(self)\nGet the supervisor’s favourite viable student.\nA student is viable if they are not currently matched to, but have a preference of, one of the supervisor’s under-subscribed projects. This method also returns the student’s favourite under-subscribed project. If no such student exists, return None.\n\n\n\nplayers.Supervisor.set_prefs(self, students)\nSet the preference list for the supervisor.\nThis method also passes the preferences on to its projects according to those students who ranked each project."
  },
  {
    "objectID": "docs/reference/exceptions.html",
    "href": "docs/reference/exceptions.html",
    "title": "exceptions",
    "section": "",
    "text": "exceptions\nExceptions for game solver checks.\n\n\n\n\n\nName\nDescription\n\n\n\n\nCapacityChangedWarning\nFor when a player has an invalid capacity.\n\n\nMatchingError\nA generic exception for erroneous matching objects.\n\n\nNoStableMatchingWarning\nFor when a game does not have a complete stable matching.\n\n\nPlayerExcludedWarning\nFor when a player should be excluded from a game.\n\n\nPreferencesChangedWarning\nFor when a player has an invalid preference list.\n\n\n\n\n\nexceptions.CapacityChangedWarning()\nFor when a player has an invalid capacity.\n\n\n\nexceptions.MatchingError(self, **kwargs)\nA generic exception for erroneous matching objects.\n\n\n\nexceptions.NoStableMatchingWarning()\nFor when a game does not have a complete stable matching.\n\n\n\nexceptions.PlayerExcludedWarning()\nFor when a player should be excluded from a game.\n\n\n\nexceptions.PreferencesChangedWarning()\nFor when a player has an invalid preference list."
  },
  {
    "objectID": "docs/reference/exceptions.html#classes",
    "href": "docs/reference/exceptions.html#classes",
    "title": "exceptions",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nCapacityChangedWarning\nFor when a player has an invalid capacity.\n\n\nMatchingError\nA generic exception for erroneous matching objects.\n\n\nNoStableMatchingWarning\nFor when a game does not have a complete stable matching.\n\n\nPlayerExcludedWarning\nFor when a player should be excluded from a game.\n\n\nPreferencesChangedWarning\nFor when a player has an invalid preference list.\n\n\n\n\n\nexceptions.CapacityChangedWarning()\nFor when a player has an invalid capacity.\n\n\n\nexceptions.MatchingError(self, **kwargs)\nA generic exception for erroneous matching objects.\n\n\n\nexceptions.NoStableMatchingWarning()\nFor when a game does not have a complete stable matching.\n\n\n\nexceptions.PlayerExcludedWarning()\nFor when a player should be excluded from a game.\n\n\n\nexceptions.PreferencesChangedWarning()\nFor when a player has an invalid preference list."
  },
  {
    "objectID": "docs/reference/SingleMatching.html",
    "href": "docs/reference/SingleMatching.html",
    "title": "SingleMatching",
    "section": "",
    "text": "matchings.SingleMatching(self, dictionary)\nMatching class for games with singular matches like SM or SR.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndictionary\n\nA dictionary comprised of Player, Optional[Player] pairs.\nrequired"
  },
  {
    "objectID": "docs/reference/SingleMatching.html#parameters",
    "href": "docs/reference/SingleMatching.html#parameters",
    "title": "SingleMatching",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndictionary\n\nA dictionary comprised of Player, Optional[Player] pairs.\nrequired"
  },
  {
    "objectID": "docs/reference/stable_roommates.html",
    "href": "docs/reference/stable_roommates.html",
    "title": "stable_roommates",
    "section": "",
    "text": "algorithms.stable_roommates\nFunctions for the SR algorithm.\n\n\n\n\n\nName\nDescription\n\n\n\n\nfirst_phase\nMake one-way proposals and forget unpreferable pairs.\n\n\nget_pairs_to_delete\nFind the set of pairs to remove given an all-or-nothing cycle.\n\n\nlocate_all_or_nothing_cycle\nLocate a cycle of (least-preferable, second-choice) pairs.\n\n\nsecond_phase\nLocate and remove all-or-nothing cycles from the game.\n\n\nstable_roommates\nIrving’s algorithm for finding a stable solution to SR.\n\n\n\n\n\nalgorithms.stable_roommates.first_phase(players)\nMake one-way proposals and forget unpreferable pairs.\n\n\n\nalgorithms.stable_roommates.get_pairs_to_delete(cycle)\nFind the set of pairs to remove given an all-or-nothing cycle.\nBased on an all-or-nothing cycle (also referred to as a “rotation”) :math:(x_1, y_1), \\ldots, (x_n, y_n), for each :math:i = 1, \\ldots, n, one must delete from the game all pairs :math:(y_i, z) such that :math:y_i prefers :math:x_{i-1} to :math:z where subscripts are taken modulo :math:n.\nThis is an important point that is omitted from the original paper, but may be found in :cite:GI89 (Section 4.2.3).\nThe essential difference between this statement and that in :cite:Irv85 is the removal of unpreferable pairs, identified using an all-or-nothing cycle, in addition to those contained in the cycle. Without doing so, tails of cycles can be removed rather than whole cycles, leaving some conflicting pairs in the game.\n\n\n\nalgorithms.stable_roommates.locate_all_or_nothing_cycle(player)\nLocate a cycle of (least-preferable, second-choice) pairs.\nAny such cycle will be removed from the game.\n\n\n\nalgorithms.stable_roommates.second_phase(players)\nLocate and remove all-or-nothing cycles from the game.\n\n\n\nalgorithms.stable_roommates.stable_roommates(players)\nIrving’s algorithm for finding a stable solution to SR.\nThe algorithm :cite:Irv85 finds stable solutions to instances of SR if one exists. Otherwise, an incomplete matching is found.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nplayers\nlist of Player\nThe players in the game. Each must rank all other players.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nA dictionary of matches where the keys and values are given by the members of players."
  },
  {
    "objectID": "docs/reference/stable_roommates.html#functions",
    "href": "docs/reference/stable_roommates.html#functions",
    "title": "stable_roommates",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfirst_phase\nMake one-way proposals and forget unpreferable pairs.\n\n\nget_pairs_to_delete\nFind the set of pairs to remove given an all-or-nothing cycle.\n\n\nlocate_all_or_nothing_cycle\nLocate a cycle of (least-preferable, second-choice) pairs.\n\n\nsecond_phase\nLocate and remove all-or-nothing cycles from the game.\n\n\nstable_roommates\nIrving’s algorithm for finding a stable solution to SR.\n\n\n\n\n\nalgorithms.stable_roommates.first_phase(players)\nMake one-way proposals and forget unpreferable pairs.\n\n\n\nalgorithms.stable_roommates.get_pairs_to_delete(cycle)\nFind the set of pairs to remove given an all-or-nothing cycle.\nBased on an all-or-nothing cycle (also referred to as a “rotation”) :math:(x_1, y_1), \\ldots, (x_n, y_n), for each :math:i = 1, \\ldots, n, one must delete from the game all pairs :math:(y_i, z) such that :math:y_i prefers :math:x_{i-1} to :math:z where subscripts are taken modulo :math:n.\nThis is an important point that is omitted from the original paper, but may be found in :cite:GI89 (Section 4.2.3).\nThe essential difference between this statement and that in :cite:Irv85 is the removal of unpreferable pairs, identified using an all-or-nothing cycle, in addition to those contained in the cycle. Without doing so, tails of cycles can be removed rather than whole cycles, leaving some conflicting pairs in the game.\n\n\n\nalgorithms.stable_roommates.locate_all_or_nothing_cycle(player)\nLocate a cycle of (least-preferable, second-choice) pairs.\nAny such cycle will be removed from the game.\n\n\n\nalgorithms.stable_roommates.second_phase(players)\nLocate and remove all-or-nothing cycles from the game.\n\n\n\nalgorithms.stable_roommates.stable_roommates(players)\nIrving’s algorithm for finding a stable solution to SR.\nThe algorithm :cite:Irv85 finds stable solutions to instances of SR if one exists. Otherwise, an incomplete matching is found.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nplayers\nlist of Player\nThe players in the game. Each must rank all other players.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nA dictionary of matches where the keys and values are given by the members of players."
  },
  {
    "objectID": "docs/reference/index.html",
    "href": "docs/reference/index.html",
    "title": "API reference",
    "section": "",
    "text": "Objects for handling game instances.\n\n\n\nStableMarriage\nSolver for the stable marriage problem (SM).\n\n\nHospitalResident\nSolver for the hospital-resident assignment problem (HR).\n\n\nStudentAllocation\nSolver for the student-allocation problem (SA).\n\n\nStableRoommates\nSolver for the stable roommates problem (SR).\n\n\n\n\n\n\nClasses to represent the players who act in games.\n\n\n\nPlayer\nGeneric single-match player class for instances of SM or SR.\n\n\nHospital\nHospital player class for instances of HR.\n\n\nProject\nProject player class for instances of SA.\n\n\nSupervisor\nSupervisor player class for instances of SA.\n\n\n\n\n\n\nModules for the algorithms that solve matching games.\n\n\n\nstable_marriage\nFunctions for the SM algorithms.\n\n\nhospital_resident\nFunctions for the HR algorithms.\n\n\nstudent_allocation\nFunctions for the SA algorithm.\n\n\nstable_roommates\nFunctions for the SR algorithm.\n\n\n\n\n\n\nDictionary-like objects for storing matchings.\n\n\n\nSingleMatching\nMatching class for games with singular matches like SM or SR.\n\n\nMultipleMatching\nMatching class for games with multiple matches like HR or SA.\n\n\n\n\n\n\nEverything else exposed in the public API.\n\n\n\nexceptions\nExceptions for game solver checks.\n\n\nbase\nAbstract base classes for inheritance."
  },
  {
    "objectID": "docs/reference/index.html#games",
    "href": "docs/reference/index.html#games",
    "title": "API reference",
    "section": "",
    "text": "Objects for handling game instances.\n\n\n\nStableMarriage\nSolver for the stable marriage problem (SM).\n\n\nHospitalResident\nSolver for the hospital-resident assignment problem (HR).\n\n\nStudentAllocation\nSolver for the student-allocation problem (SA).\n\n\nStableRoommates\nSolver for the stable roommates problem (SR)."
  },
  {
    "objectID": "docs/reference/index.html#players",
    "href": "docs/reference/index.html#players",
    "title": "API reference",
    "section": "",
    "text": "Classes to represent the players who act in games.\n\n\n\nPlayer\nGeneric single-match player class for instances of SM or SR.\n\n\nHospital\nHospital player class for instances of HR.\n\n\nProject\nProject player class for instances of SA.\n\n\nSupervisor\nSupervisor player class for instances of SA."
  },
  {
    "objectID": "docs/reference/index.html#algorithms",
    "href": "docs/reference/index.html#algorithms",
    "title": "API reference",
    "section": "",
    "text": "Modules for the algorithms that solve matching games.\n\n\n\nstable_marriage\nFunctions for the SM algorithms.\n\n\nhospital_resident\nFunctions for the HR algorithms.\n\n\nstudent_allocation\nFunctions for the SA algorithm.\n\n\nstable_roommates\nFunctions for the SR algorithm."
  },
  {
    "objectID": "docs/reference/index.html#matchings",
    "href": "docs/reference/index.html#matchings",
    "title": "API reference",
    "section": "",
    "text": "Dictionary-like objects for storing matchings.\n\n\n\nSingleMatching\nMatching class for games with singular matches like SM or SR.\n\n\nMultipleMatching\nMatching class for games with multiple matches like HR or SA."
  },
  {
    "objectID": "docs/reference/index.html#auxiliary-pieces",
    "href": "docs/reference/index.html#auxiliary-pieces",
    "title": "API reference",
    "section": "",
    "text": "Everything else exposed in the public API.\n\n\n\nexceptions\nExceptions for game solver checks.\n\n\nbase\nAbstract base classes for inheritance."
  },
  {
    "objectID": "docs/citation.html",
    "href": "docs/citation.html",
    "title": "Citations",
    "section": "",
    "text": "If you use matching then we would appreciate you citing us in your work. To do that, you have a couple of options."
  },
  {
    "objectID": "docs/citation.html#citing-the-source-code",
    "href": "docs/citation.html#citing-the-source-code",
    "title": "Citations",
    "section": "Citing the source code",
    "text": "Citing the source code\nWe maintain a DOI for each version of matching on Zenodo. Please see our archive for the correct citation details. A generic citation is:\n@misc{matching,\n    doi = {https://doi.org/10.5281/zenodo.2553125},\n    url = {https://github.com/daffidwilde/matching},\n    year = {2019},\n    title = {{Matching: A package for solving matching games}},\n    author = {{Henry Wilde and Vince Knight}}\n}"
  },
  {
    "objectID": "docs/citation.html#citing-the-paper",
    "href": "docs/citation.html#citing-the-paper",
    "title": "Citations",
    "section": "Citing the paper",
    "text": "Citing the paper\nThe Journal of Open Source Software has published a paper on matching, so if you would prefer to cite that, these are the details:\n@article{WKG20,\n    doi = {10.21105/joss.02169},\n    url = {https://doi.org/10.21105/joss.02169},\n    year = {2020},\n    publisher = {The Open Journal},\n    volume = {5},\n    number = {48},\n    pages = {2169},\n    author = {Henry Wilde and Vincent Knight and Jonathan Gillard},\n    title = {Matching: A Python library for solving matching games},\n    journal = {Journal of Open Source Software}\n}"
  },
  {
    "objectID": "docs/how-to/check_matching_status.html",
    "href": "docs/how-to/check_matching_status.html",
    "title": "Check the status of a matching",
    "section": "",
    "text": "Verifying the validity and stability of a matching is paramount in any matching game. In matching this is done by creating an instance of a game and using the check_validity and check_stability methods of the instance.\nConsider the following instance of SA.\n\nfrom matching.games import StudentAllocation\n\nstudent_preferences = {\n    \"A\": [\"X1\", \"X2\"],\n    \"B\": [\"Y2\", \"X1\"],\n    \"C\": [\"X1\", \"Y1\"],\n    \"D\": [\"Y2\", \"Y1\"],\n}\n\nsupervisor_preferences = {\"X\": [\"C\", \"A\", \"B\"], \"Y\": [\"C\", \"D\", \"B\"]}\n\nproject_supervisors = {\"X1\": \"X\", \"X2\": \"X\", \"Y1\": \"Y\", \"Y2\": \"Y\"}\nproject_capacities = {project: 1 for project in project_supervisors}\nsupervisor_capacities = {\n    supervisor: 2 for supervisor in supervisor_preferences\n}\n\n\ngame = StudentAllocation.create_from_dictionaries(\n    student_preferences,\n    supervisor_preferences,\n    project_supervisors,\n    project_capacities,\n    supervisor_capacities,\n)\n\nAn easy way to get a matching is just to solve the game. From there we can verify the status of the current matching.\n\ngame.solve()\n\ngame.check_validity(), game.check_stability()\n\n(True, True)"
  },
  {
    "objectID": "docs/how-to/choose_optimality.html",
    "href": "docs/how-to/choose_optimality.html",
    "title": "Choose party-optimality",
    "section": "",
    "text": "Many two-sided matching games allow for the optimality of its stable matching to be chosen. This is done using the optimal parameter in the corresponding class’ solve method where the party for whom the solution should be optimal is specified.\nTo see how this may change things, consider the example below.\n\nfrom matching.games import StableMarriage\n\nsuitor_preferences = {\n    \"A\": [\"X\", \"Y\", \"Z\"],\n    \"B\": [\"Y\", \"Z\", \"X\"],\n    \"C\": [\"Y\", \"X\", \"Z\"],\n}\n\nreviewer_preferences = {\n    \"X\": [\"B\", \"C\", \"A\"],\n    \"Y\": [\"A\", \"C\", \"B\"],\n    \"Z\": [\"A\", \"B\", \"C\"],\n}\n\nIn the case of SM, the choices are \"suitor\" or \"reviewer\".\n\ngame = StableMarriage.create_from_dictionaries(\n    suitor_preferences, reviewer_preferences\n)\n\ngame.solve(optimal=\"suitor\")\n\n{A: X, B: Z, C: Y}\n\n\n\ngame = StableMarriage.create_from_dictionaries(\n    suitor_preferences, reviewer_preferences\n)\n\ngame.solve(optimal=\"reviewer\")\n\n{A: Y, B: Z, C: X}"
  },
  {
    "objectID": "docs/how-to/index.html",
    "href": "docs/how-to/index.html",
    "title": "How-to Guides",
    "section": "",
    "text": "Each of these guides shows you how to do a specific task with matching.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCheck the status of a matching\n\n\n\n\nChoose party-optimality\n\n\n\n\nCreate a game from Player instances\n\n\n\n\nCreate a game from dictionaries\n\n\n\n\nRemove banned pairs\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to the matching documentation!",
    "section": "",
    "text": "GitHub repository\n  \n  \n    \n     JOSS paper\n  \n  \n    \n     Zenodo archive"
  },
  {
    "objectID": "index.html#what-is-matching",
    "href": "index.html#what-is-matching",
    "title": "Welcome to the matching documentation!",
    "section": "What is matching?",
    "text": "What is matching?\nThe matching package is all about solving matching games in Python."
  },
  {
    "objectID": "index.html#what-is-a-matching-game",
    "href": "index.html#what-is-a-matching-game",
    "title": "Welcome to the matching documentation!",
    "section": "What is a matching game?",
    "text": "What is a matching game?\nMatching games allow for the allocation of resources and partnerships in a fair way. Typically, a game is built around a collection of players and their preferences over other players.\nThe objective of the game is to find a mapping in which everyone is happy enough with their match."
  },
  {
    "objectID": "index.html#what-kind-of-games-can-i-expect",
    "href": "index.html#what-kind-of-games-can-i-expect",
    "title": "Welcome to the matching documentation!",
    "section": "What kind of games can I expect?",
    "text": "What kind of games can I expect?\nIn matching, we currently deal with the following types of game:\n\nthe stable marriage problem (SM)\nthe hospital-resident problem (HR)\nthe student-allocation problem (SA)\nthe stable roommates problem (SR)"
  },
  {
    "objectID": "CHANGES.html",
    "href": "CHANGES.html",
    "title": "matching",
    "section": "",
    "text": "Restructure the project to use pyproject.toml and tox\nImprove the documentation (reformatted doc-strings, migrating to Quarto and GitHub Pages)\nMinor fixes to ensure CI"
  },
  {
    "objectID": "CHANGES.html#v1.4.1---2023-08-30",
    "href": "CHANGES.html#v1.4.1---2023-08-30",
    "title": "matching",
    "section": "",
    "text": "Restructure the project to use pyproject.toml and tox\nImprove the documentation (reformatted doc-strings, migrating to Quarto and GitHub Pages)\nMinor fixes to ensure CI"
  },
  {
    "objectID": "CHANGES.html#v1.4---2020-11-04",
    "href": "CHANGES.html#v1.4---2020-11-04",
    "title": "matching",
    "section": "v1.4 - 2020-11-04",
    "text": "v1.4 - 2020-11-04\n\nAdd abstract classes for players, games and matchings.\nImplement extended algorithm for SR, and clean up HR/SM algorithms.\nMove all of the algorithms to their own module, matching.algorithms."
  },
  {
    "objectID": "CHANGES.html#v1.3.3---2020-10-15",
    "href": "CHANGES.html#v1.3.3---2020-10-15",
    "title": "matching",
    "section": "v1.3.3 - 2020-10-15",
    "text": "v1.3.3 - 2020-10-15\n\nMove unmatching to second phase in SR (allows for simple games.)\nMinor docs fixes."
  },
  {
    "objectID": "CHANGES.html#v1.3.2---2020-07-05",
    "href": "CHANGES.html#v1.3.2---2020-07-05",
    "title": "matching",
    "section": "v1.3.2 - 2020-07-05",
    "text": "v1.3.2 - 2020-07-05\n\nAdd HR input check for non-positive hospital capacities.\nRemove recursive flag from isort call in CI.\nMinor clean up of README images."
  },
  {
    "objectID": "CHANGES.html#v1.3.1---2020-05-26",
    "href": "CHANGES.html#v1.3.1---2020-05-26",
    "title": "matching",
    "section": "v1.3.1 - 2020-05-26",
    "text": "v1.3.1 - 2020-05-26\n\nMinor docs fixes."
  },
  {
    "objectID": "CHANGES.html#v1.3.0---2020-04-17",
    "href": "CHANGES.html#v1.3.0---2020-04-17",
    "title": "matching",
    "section": "v1.3.0 - 2020-04-17",
    "text": "v1.3.0 - 2020-04-17\n\nUpdate the self-citation information in paper.bib to v1.3."
  },
  {
    "objectID": "CHANGES.html#v1.3---2020-04-14",
    "href": "CHANGES.html#v1.3---2020-04-14",
    "title": "matching",
    "section": "v1.3 - 2020-04-14",
    "text": "v1.3 - 2020-04-14\n\nPlayers are now copied via copy.deepcopy when a game is created and the copies are used, leaving any originals unchanged.\nFormalise test and Python requirements in setup.py.\nRevert flaky forgetting fix from v1.2.1 and correct the flaky tests that were causing the issue.\nReplace the Game class with BaseGame and make it a metaclass via abc.ABCMeta.\nFix bugs in documentation stopping build."
  },
  {
    "objectID": "CHANGES.html#v1.2.1---2020-02-28",
    "href": "CHANGES.html#v1.2.1---2020-02-28",
    "title": "matching",
    "section": "v1.2.1 - 2020-02-28",
    "text": "v1.2.1 - 2020-02-28\n\nFinish documentation.\nComplete paper for submission to JOSS.\nCatch flaky forgetting bug in Player."
  },
  {
    "objectID": "CHANGES.html#v1.2---2020-02-24",
    "href": "CHANGES.html#v1.2---2020-02-24",
    "title": "matching",
    "section": "v1.2 - 2020-02-24",
    "text": "v1.2 - 2020-02-24\n\nImplement the stable roommates problem.\nAdd example tests to all games.\nFlesh out documentation."
  },
  {
    "objectID": "CHANGES.html#v1.1---2019-05-10",
    "href": "CHANGES.html#v1.1---2019-05-10",
    "title": "matching",
    "section": "v1.1 - 2019-05-10",
    "text": "v1.1 - 2019-05-10\n\nImplemented the student-allocation problem.\nAdded capability for large game creation from dictionaries."
  },
  {
    "objectID": "CHANGES.html#v1.0.2---2019-01-30",
    "href": "CHANGES.html#v1.0.2---2019-01-30",
    "title": "matching",
    "section": "v1.0.2 - 2019-01-30",
    "text": "v1.0.2 - 2019-01-30\n\nIndividuals forget the names of others one at a time rather than all instances at once as previously.\nAdd citation file."
  },
  {
    "objectID": "CHANGES.html#v1.0.1---2019-01-28",
    "href": "CHANGES.html#v1.0.1---2019-01-28",
    "title": "matching",
    "section": "v1.0.1 - 2019-01-28",
    "text": "v1.0.1 - 2019-01-28\n\nUpdate travis.yml to stop failures. Dodgy support for Python &lt;3.6.\nAdd new badges."
  },
  {
    "objectID": "CHANGES.html#v1.0---2019-01-22",
    "href": "CHANGES.html#v1.0---2019-01-22",
    "title": "matching",
    "section": "v1.0 - 2019-01-22",
    "text": "v1.0 - 2019-01-22\nThe main changes are as follows:\n\nInstead of passing dictionaries to an algorithm function, lists of matching.Player instances must be created for the two matching parties.\nEach of these instances have a few attributes but, most importantly, they take a name (this should be unique to the party) and a list (or tuple) ranking their preferences of the names of the other party’s members.\nWith these lists of Player instances, each type of matching game now has its own solver class (e.g. the hospital-resident assignment problem uses matching.HospitalResident) with various methods to solve the game and then check the stability/validity of a matching.\n\nFurther details given in new README.rst."
  },
  {
    "objectID": "CHANGES.html#v0.1---2018-03-22",
    "href": "CHANGES.html#v0.1---2018-03-22",
    "title": "matching",
    "section": "v0.1 - 2018-03-22",
    "text": "v0.1 - 2018-03-22\nFirst release. Two main algorithm functions for SM and HR."
  },
  {
    "objectID": "paper.html",
    "href": "paper.html",
    "title": "Matching: A Python library for solving matching games",
    "section": "",
    "text": "Summary\nMatching games allow for the allocation of resources and partnerships in a fair way. Typically, a matching game is defined by two sets of players that each have preferences over at least some of the elements of the other set. The objective of the game is then to find a mapping between the sets of players in which everyone is happy enough with their match.\nOne of the most ubiquitous matching games is the Stable Marriage Problem (SM). In SM, there are two distinct player sets of size \\(N\\): a set of suitors \\(S\\) and a set of reviewers \\(R\\). Each suitor must strictly rank all of the reviewers, and vice versa. This arrangement of suitors, reviewers, and their preferences is called a game of size \\(N\\) (Gale and Shapley 1962).\nIn SM, a matching is any bijection \\(M\\) between \\(S\\) and \\(R\\), and it is considered to be stable (i.e. no one has a reason to modify their current match) if it contains no blocking pairs. A blocking pair is defined as any pair \\((s, r) \\in S \\times R\\) that would rather be matched to one another than their current match. This definition differs between matching games but the spirit is the same in that a pair blocks a matching if their envy is mutually rational. Irrational envy would be where one player wishes to be matched to another over their current match but the other player does not (or cannot) reciprocate.\nConsider the game of size three shown in Figure \\(\\ref{fig:sm_matching}\\) as an edgeless graph with suitors on the left and reviewers on the right. Beside each vertex is the name of the player and their associated ranking of the complementary set’s elements.\n\n\n\nA game of size three.\n\n\nGale and Shapley (1962) presented an algorithm for finding a unique, stable and suitor-optimal matching to any instance of SM. The matching this algorithm produces is shown in Figure \\(\\ref{fig:sm_stable}\\).\n\n\n\nA stable, suitor-optimal solution.\n\n\nUsing Matching, this matching can be computed as follows:\n&gt;&gt;&gt; from matching.games import StableMarriage\n&gt;&gt;&gt; suitor_preferences = {\n...     \"A\": [\"D\", \"E\", \"F\"], \"B\": [\"D\", \"F\", \"E\"], \"C\": [\"F\", \"D\", \"E\"]\n... }\n&gt;&gt;&gt; reviewer_preferences = {\n...     \"D\": [\"B\", \"C\", \"A\"], \"E\": [\"A\", \"C\", \"B\"], \"F\": [\"C\", \"B\", \"A\"]\n... }\n&gt;&gt;&gt; game = StableMarriage.create_from_dictionaries(\n...     suitor_preferences, reviewer_preferences\n... )\n&gt;&gt;&gt; game.solve()\n{A: E, B: D, C: F}\nWhile it is relatively easy to find solutions to games like this with pen and paper, instances of other matching games tend to have more players than this and require the use of software to be solved in reasonable time.\n\n\nStatement of Need\nMatching games have applications in many fields where relationships between rational agents must be managed. Some example applications include: being able to inform on healthcare finance policy (Agarwal 2017); helping to reduce the complexity of automated wireless communication networks (Bayat et al. 2016); and education infrastructure (Chiarandini, Fagerberg, and Gualandi 2019). Thus, having access to software implementations of algorithms that are able to solve such games is essential.\nThe only current adversary to Matching is MatchingR (Tilly and Janetos 2018). MatchingR is a package written in C++ with an R interface and its content overlaps well with that of Matching. However, the lack of a Python interface makes it less relevant to researchers and other users as Python’s popularity grows both in academia and industry.\nMatching is a Python library that relies on one core library from the standard scientific Python stack – NumPy (Oliphant 2006--) – that currently implements algorithms for four types of matching games:\n\nthe stable marriage problem (SM) (Gale and Shapley 1962);\nthe hospital-resident assignment problem (HR) (Gale and Shapley 1962; Roth 1984);\nthe student-project allocation problem (SA) (Abraham, Irving, and Manlove 2007);\nthe stable roommates problem (SR) (Irving 1985).\n\nMatchingR implements all of these except SA but also implements an algorithm for the indivisible goods trading problem.\nIn addition to this, Matching has been developed to a high degree of best practice in research software development (Jiménez et al. 2017), and is thoroughly documented: matching.readthedocs.io. The documentation has been written to maximise its effect as a resource for learning about matching games as well as for the software itself. Furthermore, the software is automatically tested using example, integration, and property-based unit tests with 100% coverage. The current version of Matching has also been archived on Zenodo (The Matching library developers 2020); as has all of the data used in the documentation tutorials.\nMatching has been designed to be used as a research tool and to aid in the education of game theory. It is currently being used by a number of undergraduate students and postgraduate researchers in universities around the world, and has been used to massively streamline the final year project allocation process for one of the largest schools at Cardiff University (as an instance of SA). Furthermore, Matching proved to be instrumental in the practical implementation of a novel initialisation method for a categoric clustering algorithm (Wilde, Knight, and Gillard 2020). With Matching being written in Python, this tool is widely accessible by programmers and non-programmers alike as a readable, portable, and reproducible piece of software.\n\n\n\n\n\n\n\n\nReferences\n\nAbraham, David J., Robert W. Irving, and David F. Manlove. 2007. “Two Algorithms for the Student-Project Allocation Problem.” Journal of Discrete Algorithms 5 (1): 73–90. https://doi.org/10.1016/j.jda.2006.03.006.\n\n\nAgarwal, Nikhil. 2017. “Policy Analysis in Matching Markets.” American Economic Review 107 (5): 246–50. https://doi.org/10.1257/aer.p20171112.\n\n\nBayat, Siavash, Yonghui Li, Lingyang Song, and Zhu Han. 2016. “Matching Theory: Applications in Wireless Communications.” IEEE Signal Processing Magazine 33 (November): 103–22. https://doi.org/10.1109/MSP.2016.2598848.\n\n\nChiarandini, Marco, Rolf Fagerberg, and Stefano Gualandi. 2019. “Handling Preferences in Student-Project Allocation.” Annals of Operations Research 275 (1): 39–78. https://doi.org/10.1007/s10479-017-2710-1.\n\n\nGale, D., and L. S. Shapley. 1962. “College Admissions and the Stability of Marriage.” The American Mathematical Monthly 69 (1): 9–15. https://doi.org/10.2307/2312726.\n\n\nIrving, Robert W. 1985. “An Efficient Algorithm for the ‘Stable Roommates’ Problem.” Journal of Algorithms 6 (4): 577–95. https://doi.org/10.1016/0196-6774(85)90033-1.\n\n\nJiménez, Rafael C, Mateusz Kuzak, Monther Alhamdoosh, Michelle Barker, Bérénice Batut, Mikael Borg, Salvador Capella-Gutierrez, et al. 2017. “Four Simple Recommendations to Encourage Best Practices in Research Software.” F1000Research 6 (June): ELIXIR–876. https://doi.org/10.12688/f1000research.11407.1.\n\n\nOliphant, Travis. 2006--. “NumPy: A Guide to NumPy.” USA: Trelgol Publishing. http://www.numpy.org/.\n\n\nRoth, Alvin. 1984. “The Evolution of the Labor Market for Medical Interns and Residents: A Case Study in Game Theory.” Journal of Political Economy 92 (6): 991–1016. https://doi.org/10.1086/261272.\n\n\nThe Matching library developers. 2020. “Matching: V1.3.” https://doi.org/10.5281/zenodo.3751325.\n\n\nTilly, Jan, and Nick Janetos. 2018. “MatchingR: Matching Algorithms in R and C++.” GitHub Repository. GitHub. https://github.com/jtilly/matchingR.\n\n\nWilde, Henry, Vincent Knight, and Jonathan Gillard. 2020. “A Novel Initialisation Based on Hospital-Resident Assignment for the \\(k\\)-Modes Algorithm.” https://arxiv.org/abs/2002.02701."
  },
  {
    "objectID": "docs/contributing.html",
    "href": "docs/contributing.html",
    "title": "Contributing to the library",
    "section": "",
    "text": "If you are interested in contributing to the matching then first of all we would like to offer our thanks and say welcome!\nWhether you’re looking to provide a fix for a current issue, report a bug or implement a new feature to the library, your contributions are always welcome. Pull requests are a good place to discuss contributions so please do not feel you must present a perfect product from the off."
  },
  {
    "objectID": "docs/contributing.html#quick-start",
    "href": "docs/contributing.html#quick-start",
    "title": "Contributing to the library",
    "section": "Quick-start",
    "text": "Quick-start\nTo make a contribution via a pull request, follow these steps:\n\nGo to the GitHub repository, make a fork, and clone the repo locally:\n$ git clone git@github.com/&lt;your-username&gt;/matching.git\nAssuming you have all the dependencies installed, the next step is to ensure that all the tests pass (this should not take very long at all):\n$ cd matching\n$ pytest tests\nMake your changes and write tests to go with them, ensuring they pass, too.\nPush to your fork and open a pull request."
  },
  {
    "objectID": "docs/contributing.html#best-practices",
    "href": "docs/contributing.html#best-practices",
    "title": "Contributing to the library",
    "section": "Best practices",
    "text": "Best practices\nIf you’re interested in improving your skills as an open-source contributor, please consider this extensive guide within the Nashpy documentation. They set out some great examples and discussion there, while adhering to the Diátaxis framework for good documentation."
  },
  {
    "objectID": "docs/how-to/create_from_dictionaries.html",
    "href": "docs/how-to/create_from_dictionaries.html",
    "title": "Create a game from dictionaries",
    "section": "",
    "text": "Every game in Matching can be made using the create_from_dictionaries method (except StableRoommates which uses create_from_dictionary). This is an efficient way of creating more complex games.\nConsider the instance of SA described below.\n\nstudent_preferences = {\n    \"A\": [\"X1\", \"X2\"],\n    \"B\": [\"Y2\", \"X1\"],\n    \"C\": [\"X1\", \"Y1\"],\n    \"D\": [\"Y2\", \"Y1\"],\n}\n\nsupervisor_preferences = {\"X\": [\"C\", \"A\", \"B\"], \"Y\": [\"C\", \"D\", \"B\"]}\n\nproject_supervisors = {\"X1\": \"X\", \"X2\": \"X\", \"Y1\": \"Y\", \"Y2\": \"Y\"}\nproject_capacities = {project: 1 for project in project_supervisors}\nsupervisor_capacities = {\n    supervisor: 2 for supervisor in supervisor_preferences\n}\n\nNow the game can be created using the StudentAllocation class.\n\nfrom matching.games import StudentAllocation\n\ngame = StudentAllocation.create_from_dictionaries(\n    student_preferences,\n    supervisor_preferences,\n    project_supervisors,\n    project_capacities,\n    supervisor_capacities,\n)\n\nCreating a StableRoommates instance instead uses the create_from_dictionary method.\nConsider the instance of SR described below.\n\nroommate_preferences = {\n    \"A\": [\"B\", \"C\", \"D\"],\n    \"B\": [\"A\", \"C\", \"D\"],\n    \"C\": [\"D\", \"A\", \"B\"],\n    \"D\": [\"C\", \"B\", \"A\"],\n}\n\nNow the game can be created using the StableRoommates class.\n\nfrom matching.games import StableRoommates\n\ngame = StableRoommates.create_from_dictionary(roommate_preferences)"
  },
  {
    "objectID": "docs/how-to/create_from_instances.html",
    "href": "docs/how-to/create_from_instances.html",
    "title": "Create a game from Player instances",
    "section": "",
    "text": "Any game in Matching can be made by manually creating instances of the Player class (or its child classes) and setting their preferences using those instances.\nConsider the following instance of SM.\n\nfrom matching import Player\n\nsuitors = [Player(name=\"A\"), Player(name=\"B\"), Player(name=\"C\")]\nreviewers = [Player(name=\"D\"), Player(name=\"E\"), Player(name=\"F\")]\n\n(A, B, C), (D, E, F) = suitors, reviewers\n\nThe preferences are then set using the set_prefs method of whichever Player class you’re using.\n\nA.set_prefs([D, E, F])\nB.set_prefs([D, F, E])\nC.set_prefs([F, D, E])\n\nD.set_prefs([B, C, A])\nE.set_prefs([A, C, B])\nF.set_prefs([C, B, A])\n\nFinally, the game can be made by passing the lists of players directly.\n\nfrom matching.games import StableMarriage\n\ngame = StableMarriage(suitors, reviewers)"
  },
  {
    "objectID": "docs/how-to/remove_banned_pairs.html",
    "href": "docs/how-to/remove_banned_pairs.html",
    "title": "Remove banned pairs",
    "section": "",
    "text": "Sometimes you may wish to ban certain pairs of players from a matching. This can be done by removing them from the game all together.\nConsider the following preferences from an instance of HR.\n\nresident_prefs = {\n    \"A\": [\"C\"],\n    \"S\": [\"C\", \"M\"],\n    \"D\": [\"C\", \"M\", \"G\"],\n    \"J\": [\"C\", \"G\", \"M\"],\n    \"L\": [\"M\", \"C\", \"G\"],\n}\n\nhospital_prefs = {\n    \"M\": [\"D\", \"L\", \"S\", \"J\"],\n    \"C\": [\"D\", \"A\", \"S\", \"L\", \"J\"],\n    \"G\": [\"D\", \"J\", \"L\"],\n}\n\nThe pairs to be removed can be described as a list of hospital-resident tuples. This list needs to be iterated, and the preferences updated.\n\nbanned_pairs = [(\"M\", \"L\"), (\"C\", \"J\")]\nfor hospital, resident in banned_pairs:\n    hprefs = hospital_prefs[hospital]\n    rprefs = resident_prefs[resident]\n\n    if resident in hprefs:\n        hprefs.remove(resident)\n        hospital_prefs[hospital] = hprefs\n    if hospital in rprefs:\n        rprefs.remove(hospital)\n        resident_prefs[resident] = rprefs\n\n\nresident_prefs, hospital_prefs\n\n({'A': ['C'],\n  'S': ['C', 'M'],\n  'D': ['C', 'M', 'G'],\n  'J': ['G', 'M'],\n  'L': ['C', 'G']},\n {'M': ['D', 'S', 'J'], 'C': ['D', 'A', 'S', 'L'], 'G': ['D', 'J', 'L']})"
  },
  {
    "objectID": "docs/bibliography.html",
    "href": "docs/bibliography.html",
    "title": "Bibliography",
    "section": "",
    "text": "Here is a collection of the references cited throughout this set of documentation.\n\n\n\n\nReferences\n\nAbraham, David J., Robert W. Irving, and David F. Manlove. 2007. “Two Algorithms for the Student-Project Allocation Problem.” 5, no. 1: 73–90. https://doi.org/10.1016/j.jda.2006.03.006.\n\n\nAusten, Jane. 1813. Pride and Prejudice. Whitehall, London, UK: T. Egerton, Military Library.\n\n\nDavid, Larry, and Jerry Seinfeld. 1989. “Seinfeld.” NBC.\n\n\nDubins, Lester, and David Freedman. 1981. “Machiavelli and the Gale-Shapley Algorithm.” The American Mathematical Monthly 88 (7): 485–94. https://doi.org/10.2307/2321753.\n\n\nGale, David, and Lloyd Shapley. 1962. “College Admissions and the Stability of Marriage.” The American Mathematical Monthly 69 (1): 9–15. https://doi.org/10.2307/2312726.\n\n\nGarizio, Iacopo. 2019. “Py-School-Match: Matching Algorithms to Assign Students to Schools.” Journal of Open Source Software 4 (34): 1111. https://doi.org/10.21105/joss.01111.\n\n\nGusfield, Dan, and Robert W. Irving. 1989. The Stable Marriage Problem: Structure and Algorithms. Cambridge, MA, USA: MIT Press.\n\n\nIrving, Robert W. 1985. “An Efficient Algorithm for the \"Stable Roommates\" Problem.” Journal of Algorithms 6 (4): 577–95. https://doi.org/10.1016/0196-6774(85)90033-1.\n\n\nKnight, Vincent, and James Campbell. 2018. “Nashpy: A Python Library for the Computation of Nash Equilibria.” Journal of Open Source Software 3 (30): 904. https://doi.org/10.21105/joss.00904.\n\n\nKnight, Vincent, Owen Campbell, Marc Harper, Karol M. Langner, James Campbell, Thomas Campbell, Alex Carney, et al. 2016. “An Open Framework for the Reproducible Study of the Iterated Prisoner’s Dilemma.” Journal of Open Research Software 4 (1). https://doi.org/10.5334/jors.125.\n\n\nMcKelvey, Richard D., Andrew M. McLennan, and Theodore L. Turocy. 2016. “Gambit: Software Tools for Game Theory, Version 16.0.1.” http://www.gambit-project.org.\n\n\nRoth, Alvin. 1984. “The Evolution of the Labor Market for Medical Interns and Residents: A Case Study in Game Theory.” Journal of Political Economy 92 (6): 991–1016. https://doi.org/10.1086/261272."
  },
  {
    "objectID": "docs/reference/Player.html",
    "href": "docs/reference/Player.html",
    "title": "Player",
    "section": "",
    "text": "players.Player(self, name)\nGeneric single-match player class for instances of SM or SR.\nThis class is also used for residents in HR and students in SA.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nobject\nAn identifier. This should be unique and descriptive.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprefs\nlist of Player\nThe player’s preferences. Defaults to None and is updated using the set_prefs method.\n\n\npref_names\nlist\nA list of the names in prefs. Updates with prefs via set_prefs method.\n\n\nmatching\nPlayer or None\nThe current match of the player. None if not currently matched.\n\n\n_original_prefs\nlist of Player\nThe original set of player preferences.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_if_match_is_unacceptable\nCheck the acceptability of the current match.\n\n\nget_favourite\nGet the player’s favourite player.\n\n\nget_successors\nGet all the successors to the current match of the player.\n\n\n\n\n\nplayers.Player.check_if_match_is_unacceptable(self, unmatched_okay=False)\nCheck the acceptability of the current match.\nIn some games, a player being unmatched does not invalidate the game. The unmatched_okay parameter controls this behaviour.\n\n\n\nplayers.Player.get_favourite(self)\nGet the player’s favourite player.\n\n\n\nplayers.Player.get_successors(self)\nGet all the successors to the current match of the player."
  },
  {
    "objectID": "docs/reference/Player.html#parameters",
    "href": "docs/reference/Player.html#parameters",
    "title": "Player",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nname\nobject\nAn identifier. This should be unique and descriptive.\nrequired"
  },
  {
    "objectID": "docs/reference/Player.html#attributes",
    "href": "docs/reference/Player.html#attributes",
    "title": "Player",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nprefs\nlist of Player\nThe player’s preferences. Defaults to None and is updated using the set_prefs method.\n\n\npref_names\nlist\nA list of the names in prefs. Updates with prefs via set_prefs method.\n\n\nmatching\nPlayer or None\nThe current match of the player. None if not currently matched.\n\n\n_original_prefs\nlist of Player\nThe original set of player preferences."
  },
  {
    "objectID": "docs/reference/Player.html#methods",
    "href": "docs/reference/Player.html#methods",
    "title": "Player",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_if_match_is_unacceptable\nCheck the acceptability of the current match.\n\n\nget_favourite\nGet the player’s favourite player.\n\n\nget_successors\nGet all the successors to the current match of the player.\n\n\n\n\n\nplayers.Player.check_if_match_is_unacceptable(self, unmatched_okay=False)\nCheck the acceptability of the current match.\nIn some games, a player being unmatched does not invalidate the game. The unmatched_okay parameter controls this behaviour.\n\n\n\nplayers.Player.get_favourite(self)\nGet the player’s favourite player.\n\n\n\nplayers.Player.get_successors(self)\nGet all the successors to the current match of the player."
  },
  {
    "objectID": "docs/reference/student_allocation.html",
    "href": "docs/reference/student_allocation.html",
    "title": "student_allocation",
    "section": "",
    "text": "algorithms.student_allocation\nFunctions for the SA algorithm.\n\n\n\n\n\nName\nDescription\n\n\n\n\nstudent_allocation\nSolve an instance of SA by treating it as a bi-level HR instance.\n\n\nstudent_optimal\nSolve the instance of SA to be student-optimal.\n\n\nsupervisor_optimal\nSolve the instance of SA to be supervisor-optimal.\n\n\nunmatch_pair\nUnmatch a student-project pair.\n\n\n\n\n\nalgorithms.student_allocation.student_allocation(students, projects, supervisors, optimal='student')\nSolve an instance of SA by treating it as a bi-level HR instance.\nA unique, stable and optimal matching is found for the given set of students, projects and supervisors. The optimality of the matching is found with respect to one party and is subsequently the worst stable matching for the other.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstudents\nlist of Player\nThe students in the game. Each student must rank a subset of the elements of projects.\nrequired\n\n\nprojects\nlist of Project\nThe projects in the game. Each project is offered by a supervisor that governs its preferences.\nrequired\n\n\nsupervisors\nlist of Supervisor\nThe supervisors in the game. Each supervisor offers a unique subset of projects and ranks all the students that have ranked at least one of these projects.\nrequired\n\n\noptimal\nstr\nWhich party the matching should be optimised for. Must be one of \"student\" and \"supervisor\". Defaults to the former.\n'student'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nMatching\nA dictionary-like object where the keys are the members of projects and their student matches are the values.\n\n\n\n\n\n\n\nalgorithms.student_allocation.student_optimal(students, projects)\nSolve the instance of SA to be student-optimal.\nThe student-optimal algorithm is as follows:\n0. Set all students to be unassigned, and every project and\n   supervisor to be totally unsubscribed.\n\n1. Take any student, :math:`s`, that is unassigned and has a\n   non-empty preference list, and consider their most preferred\n   project, :math:`p`. Let :math:`f` denote the supervisor that\n   offers :math:`p`. Assign :math:`s` to be matched to :math:`p`\n   (and thus :math:`f`).\n\n2. If :math:`p` is now over-subscribed, find its worst current\n   match, :math:`s'`. Unmatch :math:`p` and :math:`s'`. Else if\n   :math:`f` is over-subscribed, find their worst current match,\n   :math:`s''`, and the project they are currently subscribed\n   to, :math:`p'`. Unmatch :math:`p'` and :math:`s''`.\n\n3. If :math:`p` is now at capacity, find their worst current\n   match, :math:`s'`. For each successor, :math:`t`, to\n   :math:`s'` in the preference list of :math:`p`, delete the\n   pair :math:`(p, t)` from the game.\n\n4. If :math:`f` is at capacity, find their worst current match,\n   :math:`s'`. For each successor, :math:`t`, to :math:`s'` in\n   the preference list of :math:`f`, for each project,\n   :math:`p'`, offered by :math:`f` that :math:`t` finds\n   acceptable, delete the pair :math:`(p', t)` from the game.\n\n5. Go to 1 until there are no such students left, then end.\n\n\n\nalgorithms.student_allocation.supervisor_optimal(projects, supervisors)\nSolve the instance of SA to be supervisor-optimal.\nThe supervisor-optimal algorithm is as follows:\n0. Set all students to be unassigned, and every project and\n   supervisor to be totally unsubscribed.\n\n1. Take any supervisor member, :math:`f`, that is\n   under-subscribed and whose preference list contains at least\n   one student that is not currently matched to at least one\n   acceptable (though currently under-subscribed) project\n   offered by :math:`f`. Consider the supervisor's most\n   preferred such student, :math:`s`, and that student's most\n   preferred such project, :math:`p`.\n\n2. If :math:`s` is matched to some other project, :math:`p'`,\n   then unmatch them. In any case, match :math:`s` and :math:`p`\n   (and thus :math:`f`).\n\n3. For each successor, :math:`p'`, to :math:`p` in the\n   preference list of :math:`s`, delete the pair :math:`(p', s)`\n   from the game.\n\n4. Go to 1 until there are no such supervisors, then end.\n\n\n\nalgorithms.student_allocation.unmatch_pair(student, project)\nUnmatch a student-project pair."
  },
  {
    "objectID": "docs/reference/student_allocation.html#functions",
    "href": "docs/reference/student_allocation.html#functions",
    "title": "student_allocation",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nstudent_allocation\nSolve an instance of SA by treating it as a bi-level HR instance.\n\n\nstudent_optimal\nSolve the instance of SA to be student-optimal.\n\n\nsupervisor_optimal\nSolve the instance of SA to be supervisor-optimal.\n\n\nunmatch_pair\nUnmatch a student-project pair.\n\n\n\n\n\nalgorithms.student_allocation.student_allocation(students, projects, supervisors, optimal='student')\nSolve an instance of SA by treating it as a bi-level HR instance.\nA unique, stable and optimal matching is found for the given set of students, projects and supervisors. The optimality of the matching is found with respect to one party and is subsequently the worst stable matching for the other.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstudents\nlist of Player\nThe students in the game. Each student must rank a subset of the elements of projects.\nrequired\n\n\nprojects\nlist of Project\nThe projects in the game. Each project is offered by a supervisor that governs its preferences.\nrequired\n\n\nsupervisors\nlist of Supervisor\nThe supervisors in the game. Each supervisor offers a unique subset of projects and ranks all the students that have ranked at least one of these projects.\nrequired\n\n\noptimal\nstr\nWhich party the matching should be optimised for. Must be one of \"student\" and \"supervisor\". Defaults to the former.\n'student'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nMatching\nA dictionary-like object where the keys are the members of projects and their student matches are the values.\n\n\n\n\n\n\n\nalgorithms.student_allocation.student_optimal(students, projects)\nSolve the instance of SA to be student-optimal.\nThe student-optimal algorithm is as follows:\n0. Set all students to be unassigned, and every project and\n   supervisor to be totally unsubscribed.\n\n1. Take any student, :math:`s`, that is unassigned and has a\n   non-empty preference list, and consider their most preferred\n   project, :math:`p`. Let :math:`f` denote the supervisor that\n   offers :math:`p`. Assign :math:`s` to be matched to :math:`p`\n   (and thus :math:`f`).\n\n2. If :math:`p` is now over-subscribed, find its worst current\n   match, :math:`s'`. Unmatch :math:`p` and :math:`s'`. Else if\n   :math:`f` is over-subscribed, find their worst current match,\n   :math:`s''`, and the project they are currently subscribed\n   to, :math:`p'`. Unmatch :math:`p'` and :math:`s''`.\n\n3. If :math:`p` is now at capacity, find their worst current\n   match, :math:`s'`. For each successor, :math:`t`, to\n   :math:`s'` in the preference list of :math:`p`, delete the\n   pair :math:`(p, t)` from the game.\n\n4. If :math:`f` is at capacity, find their worst current match,\n   :math:`s'`. For each successor, :math:`t`, to :math:`s'` in\n   the preference list of :math:`f`, for each project,\n   :math:`p'`, offered by :math:`f` that :math:`t` finds\n   acceptable, delete the pair :math:`(p', t)` from the game.\n\n5. Go to 1 until there are no such students left, then end.\n\n\n\nalgorithms.student_allocation.supervisor_optimal(projects, supervisors)\nSolve the instance of SA to be supervisor-optimal.\nThe supervisor-optimal algorithm is as follows:\n0. Set all students to be unassigned, and every project and\n   supervisor to be totally unsubscribed.\n\n1. Take any supervisor member, :math:`f`, that is\n   under-subscribed and whose preference list contains at least\n   one student that is not currently matched to at least one\n   acceptable (though currently under-subscribed) project\n   offered by :math:`f`. Consider the supervisor's most\n   preferred such student, :math:`s`, and that student's most\n   preferred such project, :math:`p`.\n\n2. If :math:`s` is matched to some other project, :math:`p'`,\n   then unmatch them. In any case, match :math:`s` and :math:`p`\n   (and thus :math:`f`).\n\n3. For each successor, :math:`p'`, to :math:`p` in the\n   preference list of :math:`s`, delete the pair :math:`(p', s)`\n   from the game.\n\n4. Go to 1 until there are no such supervisors, then end.\n\n\n\nalgorithms.student_allocation.unmatch_pair(student, project)\nUnmatch a student-project pair."
  },
  {
    "objectID": "docs/reference/HospitalResident.html",
    "href": "docs/reference/HospitalResident.html",
    "title": "HospitalResident",
    "section": "",
    "text": "games.HospitalResident(self, residents, hospitals, clean=False)\nSolver for the hospital-resident assignment problem (HR).\nIn this case, a blocking pair is any resident-hospital pair that satisfies all of the following:\n- They are present in each other's preference lists;\n- either the resident is unmatched, or they prefer the hospital\n  to their current match;\n- either the hospital is under-subscribed, or they prefer the\n  resident to at least one of their current matches.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nresidents\nlist of Player\nThe residents in the matching game. Each resident must rank a subset of those in hospitals.\nrequired\n\n\nhospitals\nlist of Hospital\nThe hospitals in the matching game. Each hospital must rank all of (and only) the residents which rank it.\nrequired\n\n\nclean\nbool\nIndicator for whether the players of the game should be cleaned. Cleaning is reductive in nature, removing players from the game and/or other player’s preferences if they do not meet the requirements of the game.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmatching\nMultipleMatching or None\nOnce the game is solved, a matching is available as a MultipleMatching object with the hospitals as keys and their resident matches as values. Initialises as None.\n\n\nblocking_pairs\nlist of (Player, Hospital) or None\nInitialises as None. Otherwise, a list of the resident-hospital blocking pairs.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_inputs\nCheck if any rules of the game have been broken.\n\n\ncheck_stability\nCheck for the existence of any blocking pairs.\n\n\ncheck_validity\nCheck whether the current matching is valid.\n\n\ncreate_from_dictionaries\nCreate an instance from a set of dictionaries.\n\n\nsolve\nSolve the instance of HR. Return the matching.\n\n\n\n\n\ngames.HospitalResident.check_inputs(self)\nCheck if any rules of the game have been broken.\nAny violations will be flagged as warnings. If the clean attribute is in use, then any violations will be removed.\n\n\n\ngames.HospitalResident.check_stability(self)\nCheck for the existence of any blocking pairs.\n\n\n\ngames.HospitalResident.check_validity(self)\nCheck whether the current matching is valid.\n\n\n\ngames.HospitalResident.create_from_dictionaries(cls, resident_prefs, hospital_prefs, capacities, clean=False)\nCreate an instance from a set of dictionaries.\nA preference dictionary for residents and hospitals is required, along with a dictionary detailing the hospital capacities. If clean, then remove players from the game and/or player preferences if they do not satisfy the conditions of the game.\n\n\n\ngames.HospitalResident.solve(self, optimal='resident')\nSolve the instance of HR. Return the matching.\nThe party optimality can be controlled using the optimal parameter."
  },
  {
    "objectID": "docs/reference/HospitalResident.html#parameters",
    "href": "docs/reference/HospitalResident.html#parameters",
    "title": "HospitalResident",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nresidents\nlist of Player\nThe residents in the matching game. Each resident must rank a subset of those in hospitals.\nrequired\n\n\nhospitals\nlist of Hospital\nThe hospitals in the matching game. Each hospital must rank all of (and only) the residents which rank it.\nrequired\n\n\nclean\nbool\nIndicator for whether the players of the game should be cleaned. Cleaning is reductive in nature, removing players from the game and/or other player’s preferences if they do not meet the requirements of the game.\nFalse"
  },
  {
    "objectID": "docs/reference/HospitalResident.html#attributes",
    "href": "docs/reference/HospitalResident.html#attributes",
    "title": "HospitalResident",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nmatching\nMultipleMatching or None\nOnce the game is solved, a matching is available as a MultipleMatching object with the hospitals as keys and their resident matches as values. Initialises as None.\n\n\nblocking_pairs\nlist of (Player, Hospital) or None\nInitialises as None. Otherwise, a list of the resident-hospital blocking pairs."
  },
  {
    "objectID": "docs/reference/HospitalResident.html#methods",
    "href": "docs/reference/HospitalResident.html#methods",
    "title": "HospitalResident",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_inputs\nCheck if any rules of the game have been broken.\n\n\ncheck_stability\nCheck for the existence of any blocking pairs.\n\n\ncheck_validity\nCheck whether the current matching is valid.\n\n\ncreate_from_dictionaries\nCreate an instance from a set of dictionaries.\n\n\nsolve\nSolve the instance of HR. Return the matching.\n\n\n\n\n\ngames.HospitalResident.check_inputs(self)\nCheck if any rules of the game have been broken.\nAny violations will be flagged as warnings. If the clean attribute is in use, then any violations will be removed.\n\n\n\ngames.HospitalResident.check_stability(self)\nCheck for the existence of any blocking pairs.\n\n\n\ngames.HospitalResident.check_validity(self)\nCheck whether the current matching is valid.\n\n\n\ngames.HospitalResident.create_from_dictionaries(cls, resident_prefs, hospital_prefs, capacities, clean=False)\nCreate an instance from a set of dictionaries.\nA preference dictionary for residents and hospitals is required, along with a dictionary detailing the hospital capacities. If clean, then remove players from the game and/or player preferences if they do not satisfy the conditions of the game.\n\n\n\ngames.HospitalResident.solve(self, optimal='resident')\nSolve the instance of HR. Return the matching.\nThe party optimality can be controlled using the optimal parameter."
  },
  {
    "objectID": "docs/reference/base.html",
    "href": "docs/reference/base.html",
    "title": "base",
    "section": "",
    "text": "base\nAbstract base classes for inheritance.\n\n\n\n\n\nName\nDescription\n\n\n\n\nBaseGame\nAn abstract base class for facilitating various matching games.\n\n\nBaseMatching\nAn abstract base class for storing and updating a matching.\n\n\nBasePlayer\nAn abstract base class to represent a player within a matching game.\n\n\n\n\n\nbase.BaseGame(self, clean=False)\nAn abstract base class for facilitating various matching games.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nclean\nbool\nDefaults to False. If True, when passing a set of players to create a game instance, they will be automatically cleaned.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmatching\nBaseMatching or None\nAfter solving the game, an object whose class inherits from BaseMatching is found here. Otherwise, None.\n\n\nblocking_pairs\nlist of (BasePlayer, BasePlayer) or None\nAfter checking the stability of the game instance, a list of any pairs that block the stability of the matching is found here. Otherwise, None.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_stability\nPlaceholder for checking the stability of the matching.\n\n\ncheck_validity\nPlaceholder for checking the validity of the matching.\n\n\nsolve\nPlaceholder for solving the game instance.\n\n\n\n\n\nbase.BaseGame.check_stability(self)\nPlaceholder for checking the stability of the matching.\n\n\n\nbase.BaseGame.check_validity(self)\nPlaceholder for checking the validity of the matching.\n\n\n\nbase.BaseGame.solve(self)\nPlaceholder for solving the game instance.\n\n\n\n\n\nbase.BaseMatching(self, dictionary=None)\nAn abstract base class for storing and updating a matching.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndictionary\ndict or None\nIf not None, a dictionary mapping a Player to one of: None, a single Player or a list of Player instances.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nkeys\nGet the underlying dictionary keys.\n\n\nvalues\nGet the underlying dictionary values.\n\n\n\n\n\nbase.BaseMatching.keys(self)\nGet the underlying dictionary keys.\n\n\n\nbase.BaseMatching.values(self)\nGet the underlying dictionary values.\n\n\n\n\n\nbase.BasePlayer(self, name)\nAn abstract base class to represent a player within a matching game.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nobject\nAn identifier. This should be unique and descriptive.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprefs\nList[BasePlayer]\nThe player’s preferences. Defaults to None and is updated using the set_prefs method.\n\n\nmatching\nOptional[BasePlayer]\nThe current match of the player. None if not currently matched.\n\n\n_pref_names\nOptional[List]\nA list of the names in prefs. Updates with prefs via set_prefs method.\n\n\n_original_prefs\nOptional[List[BasePlayer]]\nThe original set of player preferences. Defaults to None and does not update after the first set_prefs method call.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_if_match_is_unacceptable\nPlaceholder for checking player’s match is acceptable.\n\n\nget_favourite\nPlaceholder for getting the player’s favourite player.\n\n\nget_successors\nPlaceholder for getting the successors of a match.\n\n\nnot_in_preferences_message\nMessage to say another player is an unacceptable match.\n\n\nprefers\nDetermines whether the player prefers a player over some other\n\n\nset_prefs\nSet the player’s preferences to be a list of players.\n\n\nunmatched_message\nMessage to say the player is not matched.\n\n\n\n\n\nbase.BasePlayer.check_if_match_is_unacceptable(self)\nPlaceholder for checking player’s match is acceptable.\n\n\n\nbase.BasePlayer.get_favourite(self)\nPlaceholder for getting the player’s favourite player.\n\n\n\nbase.BasePlayer.get_successors(self)\nPlaceholder for getting the successors of a match.\n\n\n\nbase.BasePlayer.not_in_preferences_message(self, other)\nMessage to say another player is an unacceptable match.\n\n\n\nbase.BasePlayer.prefers(self, player, other)\nDetermines whether the player prefers a player over some other player.\n\n\n\nbase.BasePlayer.set_prefs(self, players)\nSet the player’s preferences to be a list of players.\n\n\n\nbase.BasePlayer.unmatched_message(self)\nMessage to say the player is not matched."
  },
  {
    "objectID": "docs/reference/base.html#classes",
    "href": "docs/reference/base.html#classes",
    "title": "base",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBaseGame\nAn abstract base class for facilitating various matching games.\n\n\nBaseMatching\nAn abstract base class for storing and updating a matching.\n\n\nBasePlayer\nAn abstract base class to represent a player within a matching game.\n\n\n\n\n\nbase.BaseGame(self, clean=False)\nAn abstract base class for facilitating various matching games.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nclean\nbool\nDefaults to False. If True, when passing a set of players to create a game instance, they will be automatically cleaned.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmatching\nBaseMatching or None\nAfter solving the game, an object whose class inherits from BaseMatching is found here. Otherwise, None.\n\n\nblocking_pairs\nlist of (BasePlayer, BasePlayer) or None\nAfter checking the stability of the game instance, a list of any pairs that block the stability of the matching is found here. Otherwise, None.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_stability\nPlaceholder for checking the stability of the matching.\n\n\ncheck_validity\nPlaceholder for checking the validity of the matching.\n\n\nsolve\nPlaceholder for solving the game instance.\n\n\n\n\n\nbase.BaseGame.check_stability(self)\nPlaceholder for checking the stability of the matching.\n\n\n\nbase.BaseGame.check_validity(self)\nPlaceholder for checking the validity of the matching.\n\n\n\nbase.BaseGame.solve(self)\nPlaceholder for solving the game instance.\n\n\n\n\n\nbase.BaseMatching(self, dictionary=None)\nAn abstract base class for storing and updating a matching.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndictionary\ndict or None\nIf not None, a dictionary mapping a Player to one of: None, a single Player or a list of Player instances.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nkeys\nGet the underlying dictionary keys.\n\n\nvalues\nGet the underlying dictionary values.\n\n\n\n\n\nbase.BaseMatching.keys(self)\nGet the underlying dictionary keys.\n\n\n\nbase.BaseMatching.values(self)\nGet the underlying dictionary values.\n\n\n\n\n\nbase.BasePlayer(self, name)\nAn abstract base class to represent a player within a matching game.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nobject\nAn identifier. This should be unique and descriptive.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprefs\nList[BasePlayer]\nThe player’s preferences. Defaults to None and is updated using the set_prefs method.\n\n\nmatching\nOptional[BasePlayer]\nThe current match of the player. None if not currently matched.\n\n\n_pref_names\nOptional[List]\nA list of the names in prefs. Updates with prefs via set_prefs method.\n\n\n_original_prefs\nOptional[List[BasePlayer]]\nThe original set of player preferences. Defaults to None and does not update after the first set_prefs method call.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_if_match_is_unacceptable\nPlaceholder for checking player’s match is acceptable.\n\n\nget_favourite\nPlaceholder for getting the player’s favourite player.\n\n\nget_successors\nPlaceholder for getting the successors of a match.\n\n\nnot_in_preferences_message\nMessage to say another player is an unacceptable match.\n\n\nprefers\nDetermines whether the player prefers a player over some other\n\n\nset_prefs\nSet the player’s preferences to be a list of players.\n\n\nunmatched_message\nMessage to say the player is not matched.\n\n\n\n\n\nbase.BasePlayer.check_if_match_is_unacceptable(self)\nPlaceholder for checking player’s match is acceptable.\n\n\n\nbase.BasePlayer.get_favourite(self)\nPlaceholder for getting the player’s favourite player.\n\n\n\nbase.BasePlayer.get_successors(self)\nPlaceholder for getting the successors of a match.\n\n\n\nbase.BasePlayer.not_in_preferences_message(self, other)\nMessage to say another player is an unacceptable match.\n\n\n\nbase.BasePlayer.prefers(self, player, other)\nDetermines whether the player prefers a player over some other player.\n\n\n\nbase.BasePlayer.set_prefs(self, players)\nSet the player’s preferences to be a list of players.\n\n\n\nbase.BasePlayer.unmatched_message(self)\nMessage to say the player is not matched."
  },
  {
    "objectID": "docs/reference/Project.html",
    "href": "docs/reference/Project.html",
    "title": "Project",
    "section": "",
    "text": "players.Project(self, name, capacity)\nProject player class for instances of SA.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nobject\nAn identifier. This should be unique and descriptive.\nrequired\n\n\ncapacity\nint\nThe maximum number of matches the project can have.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsupervisor\nSupervisor\nThe supervisor that runs the project. Defaults to None. Controlled using the set_supervisor method.\n\n\nprefs\nlist of Player\nThe project’s preferences. Inherited from supervisor and set via the Supervisor.set_prefs method.\n\n\nmatching\nlist of Player\nThe current matches of the project. An empty list if currently unsubscribed.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_supervisor\nAssign the supervisor to the project.\n\n\n\n\n\nplayers.Project.set_supervisor(self, supervisor)\nAssign the supervisor to the project.\nThis method also update the supervisor’s project list."
  },
  {
    "objectID": "docs/reference/Project.html#parameters",
    "href": "docs/reference/Project.html#parameters",
    "title": "Project",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nname\nobject\nAn identifier. This should be unique and descriptive.\nrequired\n\n\ncapacity\nint\nThe maximum number of matches the project can have.\nrequired"
  },
  {
    "objectID": "docs/reference/Project.html#attributes",
    "href": "docs/reference/Project.html#attributes",
    "title": "Project",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nsupervisor\nSupervisor\nThe supervisor that runs the project. Defaults to None. Controlled using the set_supervisor method.\n\n\nprefs\nlist of Player\nThe project’s preferences. Inherited from supervisor and set via the Supervisor.set_prefs method.\n\n\nmatching\nlist of Player\nThe current matches of the project. An empty list if currently unsubscribed."
  },
  {
    "objectID": "docs/reference/Project.html#methods",
    "href": "docs/reference/Project.html#methods",
    "title": "Project",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nset_supervisor\nAssign the supervisor to the project.\n\n\n\n\n\nplayers.Project.set_supervisor(self, supervisor)\nAssign the supervisor to the project.\nThis method also update the supervisor’s project list."
  },
  {
    "objectID": "docs/reference/StableRoommates.html",
    "href": "docs/reference/StableRoommates.html",
    "title": "StableRoommates",
    "section": "",
    "text": "games.StableRoommates(self, players)\nSolver for the stable roommates problem (SR).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nplayers\nlist of Player\nThe players in the game. Each must rank all other players.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmatching\nSingleMatching or None\nOnce the game is solved, a matching is available. This uses the players as keys and values in a SingleMatching object. Initialises as None.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_inputs\nCheck that all players have ranked all other players.\n\n\ncheck_stability\nCheck for the stability of the current matching.\n\n\ncheck_validity\nCheck whether the current matching is valid.\n\n\ncreate_from_dictionary\nCreate an instance of SR from a preference dictionary.\n\n\nsolve\nAttempt to solve the instance of SR. Return the matching.\n\n\n\n\n\ngames.StableRoommates.check_inputs(self)\nCheck that all players have ranked all other players.\n\n\n\ngames.StableRoommates.check_stability(self)\nCheck for the stability of the current matching.\nSM stability requires there to be no blocking pairs and all players to be matched.\n\n\n\ngames.StableRoommates.check_validity(self)\nCheck whether the current matching is valid.\n\n\n\ngames.StableRoommates.create_from_dictionary(cls, player_prefs)\nCreate an instance of SR from a preference dictionary.\n\n\n\ngames.StableRoommates.solve(self)\nAttempt to solve the instance of SR. Return the matching."
  },
  {
    "objectID": "docs/reference/StableRoommates.html#parameters",
    "href": "docs/reference/StableRoommates.html#parameters",
    "title": "StableRoommates",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nplayers\nlist of Player\nThe players in the game. Each must rank all other players.\nrequired"
  },
  {
    "objectID": "docs/reference/StableRoommates.html#attributes",
    "href": "docs/reference/StableRoommates.html#attributes",
    "title": "StableRoommates",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nmatching\nSingleMatching or None\nOnce the game is solved, a matching is available. This uses the players as keys and values in a SingleMatching object. Initialises as None."
  },
  {
    "objectID": "docs/reference/StableRoommates.html#methods",
    "href": "docs/reference/StableRoommates.html#methods",
    "title": "StableRoommates",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_inputs\nCheck that all players have ranked all other players.\n\n\ncheck_stability\nCheck for the stability of the current matching.\n\n\ncheck_validity\nCheck whether the current matching is valid.\n\n\ncreate_from_dictionary\nCreate an instance of SR from a preference dictionary.\n\n\nsolve\nAttempt to solve the instance of SR. Return the matching.\n\n\n\n\n\ngames.StableRoommates.check_inputs(self)\nCheck that all players have ranked all other players.\n\n\n\ngames.StableRoommates.check_stability(self)\nCheck for the stability of the current matching.\nSM stability requires there to be no blocking pairs and all players to be matched.\n\n\n\ngames.StableRoommates.check_validity(self)\nCheck whether the current matching is valid.\n\n\n\ngames.StableRoommates.create_from_dictionary(cls, player_prefs)\nCreate an instance of SR from a preference dictionary.\n\n\n\ngames.StableRoommates.solve(self)\nAttempt to solve the instance of SR. Return the matching."
  },
  {
    "objectID": "docs/reference/MultipleMatching.html",
    "href": "docs/reference/MultipleMatching.html",
    "title": "MultipleMatching",
    "section": "",
    "text": "matchings.MultipleMatching(self, dictionary)\nMatching class for games with multiple matches like HR or SA.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndictionary\n\nA dictionary comprised of Hospital, List[Player] pairs.\nrequired"
  },
  {
    "objectID": "docs/reference/MultipleMatching.html#parameters",
    "href": "docs/reference/MultipleMatching.html#parameters",
    "title": "MultipleMatching",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndictionary\n\nA dictionary comprised of Hospital, List[Player] pairs.\nrequired"
  },
  {
    "objectID": "docs/reference/StudentAllocation.html",
    "href": "docs/reference/StudentAllocation.html",
    "title": "StudentAllocation",
    "section": "",
    "text": "games.StudentAllocation(self, students, projects, supervisors, clean=False)\nSolver for the student-allocation problem (SA).\nIn SA, a blocking pair is defined as any student-project pair that satisfies all of the following:\n\nThe student has a preference of the project.\nEither the student is unmatched, or they prefer the project to their current project.\nAt least one of the following:\n\nThe project or its supervisor is under-subscribed.\nThe project is under-subscribed and the supervisor is at capacity, and the student is matched to a project offered by the supervisor or the supervisor prefers the student to its worst currently matched student.\nThe project is at capacity and its supervisor prefers the student to its worst currently matched student.\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstudents\nlist of Player\nThe students in the game. Each student must rank a subset of the projects.\nrequired\n\n\nprojects\nlist of Project\nThe projects in the game. Each project has a supervisor associated with it that governs its preferences.\nrequired\n\n\nsupervisors\nlist of Supervisor\nThe supervisors in the game. Each supervisor oversees a unique subset of projects and ranks all of those students that have ranked at least one of its projects.\nrequired\n\n\nclean\nbool\nAn indicator as to whether the players passed to the game should be cleaned in a reductive fashion. Defaults to False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmatching\nMultipleMatching or None\nOnce the game is solved, a matching is available. This MultipleMatching object behaves much like a dictionary that uses the elements of projects as keys and their student matches as values. Initialises as None.\n\n\nblocking_pairs\nlist of (Player, Project)\nInitialises as None. Otherwise, a list of the student-project blocking pairs.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_inputs\nCheck if any rules of the game have been broken.\n\n\ncheck_stability\nCheck for the existence of any blocking pairs.\n\n\ncheck_validity\nCheck whether the current matching is valid.\n\n\ncreate_from_dictionaries\nCreate an instance of SA from a set of dictionaries.\n\n\nsolve\nSolve the instance of SA.\n\n\n\n\n\ngames.StudentAllocation.check_inputs(self)\nCheck if any rules of the game have been broken.\nAny violations will be flagged as warnings. If the clean attribute is in use, then any violations will be removed.\n\n\n\ngames.StudentAllocation.check_stability(self)\nCheck for the existence of any blocking pairs.\n\n\n\ngames.StudentAllocation.check_validity(self)\nCheck whether the current matching is valid.\n\n\n\ngames.StudentAllocation.create_from_dictionaries(cls, student_prefs, supervisor_prefs, project_supervisors, project_capacities, supervisor_capacities, clean=False)\nCreate an instance of SA from a set of dictionaries.\nSA requires preference dictionaries for students and supervisors, a project-supervisor affiliation dictionary, and a capacity dictionary for both the projects and supervisors.\n\n\n\ngames.StudentAllocation.solve(self, optimal='student')\nSolve the instance of SA.\nParty optimality can be controlled using the optimal parameter. Solutions can either be student-optimal or supervisor-optimal."
  },
  {
    "objectID": "docs/reference/StudentAllocation.html#parameters",
    "href": "docs/reference/StudentAllocation.html#parameters",
    "title": "StudentAllocation",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nstudents\nlist of Player\nThe students in the game. Each student must rank a subset of the projects.\nrequired\n\n\nprojects\nlist of Project\nThe projects in the game. Each project has a supervisor associated with it that governs its preferences.\nrequired\n\n\nsupervisors\nlist of Supervisor\nThe supervisors in the game. Each supervisor oversees a unique subset of projects and ranks all of those students that have ranked at least one of its projects.\nrequired\n\n\nclean\nbool\nAn indicator as to whether the players passed to the game should be cleaned in a reductive fashion. Defaults to False.\nFalse"
  },
  {
    "objectID": "docs/reference/StudentAllocation.html#attributes",
    "href": "docs/reference/StudentAllocation.html#attributes",
    "title": "StudentAllocation",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nmatching\nMultipleMatching or None\nOnce the game is solved, a matching is available. This MultipleMatching object behaves much like a dictionary that uses the elements of projects as keys and their student matches as values. Initialises as None.\n\n\nblocking_pairs\nlist of (Player, Project)\nInitialises as None. Otherwise, a list of the student-project blocking pairs."
  },
  {
    "objectID": "docs/reference/StudentAllocation.html#methods",
    "href": "docs/reference/StudentAllocation.html#methods",
    "title": "StudentAllocation",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_inputs\nCheck if any rules of the game have been broken.\n\n\ncheck_stability\nCheck for the existence of any blocking pairs.\n\n\ncheck_validity\nCheck whether the current matching is valid.\n\n\ncreate_from_dictionaries\nCreate an instance of SA from a set of dictionaries.\n\n\nsolve\nSolve the instance of SA.\n\n\n\n\n\ngames.StudentAllocation.check_inputs(self)\nCheck if any rules of the game have been broken.\nAny violations will be flagged as warnings. If the clean attribute is in use, then any violations will be removed.\n\n\n\ngames.StudentAllocation.check_stability(self)\nCheck for the existence of any blocking pairs.\n\n\n\ngames.StudentAllocation.check_validity(self)\nCheck whether the current matching is valid.\n\n\n\ngames.StudentAllocation.create_from_dictionaries(cls, student_prefs, supervisor_prefs, project_supervisors, project_capacities, supervisor_capacities, clean=False)\nCreate an instance of SA from a set of dictionaries.\nSA requires preference dictionaries for students and supervisors, a project-supervisor affiliation dictionary, and a capacity dictionary for both the projects and supervisors.\n\n\n\ngames.StudentAllocation.solve(self, optimal='student')\nSolve the instance of SA.\nParty optimality can be controlled using the optimal parameter. Solutions can either be student-optimal or supervisor-optimal."
  },
  {
    "objectID": "docs/discussion/index.html",
    "href": "docs/discussion/index.html",
    "title": "Discussion",
    "section": "",
    "text": "In this section you can find some more detailed discussion around the problems implemented in matching as well as some context for the other packages out there.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe stable marriage problem\n\n\n\n\n\n\n\nThe hospital-resident assignment problem\n\n\n\n\n\n\n\nThe student-allocation problem\n\n\n\n\n\n\n\n\nThe stable roommates problem\n\n\n\n\n\n\n\nCHANGES\n\n\nA summary of the changes between each version of matching\n\n\n\n\nOther packages\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "docs/discussion/student_allocation.html",
    "href": "docs/discussion/student_allocation.html",
    "title": "The student-allocation problem",
    "section": "",
    "text": "The student-allocation problem (SA) is concerned with the allocation of students to projects and their supervisors.\nIn this kind of problem there are technically three sets of players, although supervisors and their projects act together as a set of players.\nSupervisors hold preferences over the students and pass them onto their projects. Like HR, this set of players have capacities, allowing for projects of different sizes and offering flexibility to supervisors.\n\n\n\n\nConsider three distinct sets, \\(S\\), \\(P\\) and \\(U\\), and let us refer to them as students, projects and supervisors. Each project \\(p \\in P\\) has a single supervisor \\(u \\in U\\) associated with them. This association is described as a surjective function \\(L: P \\to U\\) where the supervisor \\(u \\in U\\) for a project \\(p \\in P\\) can be written as \\(L(p) = u\\). Note that as \\(L\\) is surjective, \\(u\\) may have multiple projects associated with them and we denote their set of projects as \\(L^{-1}(u)\\).\nIn addition to this, each project \\(p \\in P\\) and supervisor \\(u \\in U\\) has a capacity associated with them, denoted \\(c_p, c_u \\in \\mathbb{N}\\) respectively. We assume that for each \\(u \\in U\\) the following holds:\n\\[\\max\\left\\{ c_p \\ | \\ p \\in L^{-1}(u) \\right\\}\n\\leq c_u \\leq\n\\sum_{p \\in L^{-1}(u)} c_p\\]\nThat is, a supervisor must be able to accommodate their largest project but not offer more spaces than their projects sum to.\nAs with other matching games, each player has a preference list associated with them. In the case of SA, we have the following constraints on those preferences:\n\nEach student \\(s \\in S\\) must rank a non-empty subset of \\(P\\). We denote this preference by \\(f(s)\\).\nEach supervisor \\(u \\in U\\) must rank all those students that have ranked at least one of their projects. That is, the preference list of \\(u\\), denoted \\(g(u)\\), is a permutation of the set given by \\(\\left\\{ s \\in S \\ | \\ L^{-1}(u) \\cap f(s) \\neq \\emptyset \\right\\}\\). If no students have ranked any of a supervisor's projects then that supervisor is removed from \\(U\\).\nThe preference list of a project \\(p \\in P\\) is governed by its supervisor \\(u = L(p)\\). We denote this preference as \\(g_p(u)\\) and it is simply \\(g(u)\\) without the students who did not rank \\(p\\). If no students have ranked a project then that project is removed from \\(P\\).\n\nThis construction of students, projects, supervisors, associations, capacities and preference lists is a game and is denoted by \\((S,P,U)\\). This game is used to model instances of SA.\n\n\n\nA matching \\(M\\) is any mapping between \\(S\\) and \\(P\\). If a pair \\((s, p) \\in S \\times P\\) are matched in \\(M\\), we say that \\(M(s) = p\\) and \\(s \\in M^{-1}(p)\\). We also note that since each supervisor \\(u \\in U\\) oversees their projects (by definition), their matching can be referred to as the union of its projects' matchings:\n\\[M^{-1}(u) = \\bigcup_{p \\in L^{-1}(u)} M^{-1}(p) \\subseteq S\\]\nA matching is only considered valid if all of the following are satisfied:\n\n\nFor all \\(s \\in S\\) with a match we have \\(M(s) \\in f(s)\\).\nFor all \\(p \\in P\\) we have \\(M^{-1}(p) \\subseteq g_p(u)\\) and \\(|M^{-1}(p)| \\leq c_p\\).\nFor all \\(u \\in U\\) we have \\(M^{-1}(u) \\subseteq g(u)\\) and \\(|M^{-1}(u)| \\leq c_u\\).\n\n\nAs always, a valid matching is considered stable if it does not contain any blocking pairs.\n\n\n\nA pair \\((s, p)\\) is said to block a matching \\(M\\) if all the following hold:\n\n\nThe student has a preference of the project, i.e. \\(p \\in f(s)\\).\nEither \\(s\\) is unmatched or they prefer \\(p\\) to \\(M(s) = p'\\).\nAt least one of the following is true, where \\(u = L(p)\\):\n\n\nBoth \\(p\\) and \\(u\\) are under-subscribed, i.e. \\(|M^{-1}(p)| &lt; c_p\\) and \\(|M^{-1}(u)| &lt; c_u\\).\n\\(|M^{-1}(p)| &lt; c_p\\) and \\(|M^{-1}(u)| = c_u\\), and either \\(M(s) = p' \\in L^{-1}(u)\\) or \\(u\\) prefers \\(s\\) to their worst current match \\(s' \\in M^{-1}(u)\\).\n\\(|M^{-1}(p)| = c_p\\) and \\(u\\) prefers \\(s\\) to the project's worst student \\(s \\in M^{-1}(p)\\).\n\n\n\n\nThe notion of preference is equivalent to that in SM.\n\n\n\n\nConsider the following instance of SA. There are five students - Avery, Blake, Cleo, Devon, Everest - in their final year of university. As part of this year, they may apply to do a project. There are two members of staff providing these projects - Dr. Xavier and Prof. Yeo. Each supervisor may take at most three students and each offer two projects with space for two students on each. The players' preferences are described in the graph below:\n\n\n\nimage\n\n\nNote that in this particular example, the students are ranked in the same order by both supervisors (as is often the case in real-world applications of SA). Now consider the matching below:\n\n\n\nimage\n\n\nThis matching is invalid, and none of the conditions for validity have been met. Specifically:\n\nAvery has been allocated Dr. Yeo's first project despite not ranking it (and likewise for Dr. Yeo and the project)\nDr. Yeo's first project has been allocated a total of three students which exceeds its capacity of two.\nIn addition to this, Dr. Yeo has been allocated a fourth student, violating their capacity constraint.\n\nWith a few changes, we can make this matching valid. Swapping Avery and Cleo with Devon is a start since they are Dr. Xavier's favourite students after Blake. Then we can move Devon to Y2 as this is their most preferred project. Doing this gives the following matching:\n\n\n\nimage\n\n\nUnfortunately, and despite our efforts to accommodate people's preferences, this matching is not stable. Here we have two blocking pairs, \\((E, X2)\\) and \\((E, Y2)\\). Although Everest prefers X1 to either of these projects, they do not form a blocking pair as X1 is full and Dr. Xavier prefers Avery and Cleo to Everest.\nSo, in order to overcome these blocking pairs without creating more, Devon must be swapped with Everest. This also feels like the fairest move given that Everest outranks Devon. The following graph displays this new, stable matching:\n\n\n\nimage\n\n\nIt also happens that this matching is student-optimal as well as being stable and valid.\n\n\n\nFinding stable and optimal solutions to SA is easily motivated since those solutions would solve the real-world problem they model. Actually implementing this in the real world is described in more detail in this tutorial.\nAs with HR, there are two algorithms implemented in Matching to solve instances of SA, one to handle the optimality of each party (students and project/supervisors). These algorithms, taken from AIM07, follow a similar structure to those for HR in that they take advantage of the inherent structure of the game. Again, each party-optimal algorithm provides a unique, stable matching for an instance of SA.\n\n\n\nAssign all students to be unmatched, and all supervisors (and their projects) to be totally unsubscribed.\nTake any student \\(s\\) that is unmatched and has a non-empty preference list, and consider their most preferred project \\(p\\). Let \\(u = L(p)\\). Assign \\(s\\) to be matched to \\(p\\) (and thus \\(u\\)).\nIf \\(p\\) is over-subscribed, find its worst current match \\(s'\\). Unmatch \\(p\\) and \\(s'\\). Else if \\(u\\) is over-subscribed, find their worst current match \\(s'\\) and the project \\(p'\\) that \\(s'\\) is assigned to. Unmatch \\(p'\\) and \\(s'\\).\nIf \\(p\\) is at capacity, find their worst current match \\(s'\\). For each successor \\(t \\in g_p(u)\\) to \\(s'\\), delete the pair \\((t, p)\\) from the game by removing \\(p\\) from \\(f(t)\\) and \\(t\\) from \\(g(u)\\) (and thus \\(g_p(u)\\)).\nIf \\(u\\) is at capacity, find their worst current match \\(s'\\). For each successor \\(t \\in g(u)\\) to \\(s'\\), delete the pair \\((t, p)\\) from the game.\nGo to 1 until there are no such students left, then end.\n\n\n\n\n\nAssign all students to be unmatched, and all supervisors (and their projects) to be totally unsubscribed.\nTake any supervisor \\(u\\) that is under-subscribed and whose preference list contains at least one student that is not currently matched to at least one acceptable (though currently under-subscribed) project offered by \\(u\\). Consider the supervisor's most preferred such student \\(s\\) and that student's most preferred such project \\(p\\).\nIf \\(s\\) is matched to some other project \\(p'\\) then unmatch them.\nAssign \\(s\\) to be matched to \\(p\\) (and thus \\(u\\)).\nFor each successor \\(p' \\in f(s)\\) to \\(p\\), delete the pair \\((s, p')\\) from the game.\nGo to 1 until there are no such supervisors, then end."
  },
  {
    "objectID": "docs/discussion/student_allocation.html#key-definitions",
    "href": "docs/discussion/student_allocation.html#key-definitions",
    "title": "The student-allocation problem",
    "section": "",
    "text": "Consider three distinct sets, \\(S\\), \\(P\\) and \\(U\\), and let us refer to them as students, projects and supervisors. Each project \\(p \\in P\\) has a single supervisor \\(u \\in U\\) associated with them. This association is described as a surjective function \\(L: P \\to U\\) where the supervisor \\(u \\in U\\) for a project \\(p \\in P\\) can be written as \\(L(p) = u\\). Note that as \\(L\\) is surjective, \\(u\\) may have multiple projects associated with them and we denote their set of projects as \\(L^{-1}(u)\\).\nIn addition to this, each project \\(p \\in P\\) and supervisor \\(u \\in U\\) has a capacity associated with them, denoted \\(c_p, c_u \\in \\mathbb{N}\\) respectively. We assume that for each \\(u \\in U\\) the following holds:\n\\[\\max\\left\\{ c_p \\ | \\ p \\in L^{-1}(u) \\right\\}\n\\leq c_u \\leq\n\\sum_{p \\in L^{-1}(u)} c_p\\]\nThat is, a supervisor must be able to accommodate their largest project but not offer more spaces than their projects sum to.\nAs with other matching games, each player has a preference list associated with them. In the case of SA, we have the following constraints on those preferences:\n\nEach student \\(s \\in S\\) must rank a non-empty subset of \\(P\\). We denote this preference by \\(f(s)\\).\nEach supervisor \\(u \\in U\\) must rank all those students that have ranked at least one of their projects. That is, the preference list of \\(u\\), denoted \\(g(u)\\), is a permutation of the set given by \\(\\left\\{ s \\in S \\ | \\ L^{-1}(u) \\cap f(s) \\neq \\emptyset \\right\\}\\). If no students have ranked any of a supervisor's projects then that supervisor is removed from \\(U\\).\nThe preference list of a project \\(p \\in P\\) is governed by its supervisor \\(u = L(p)\\). We denote this preference as \\(g_p(u)\\) and it is simply \\(g(u)\\) without the students who did not rank \\(p\\). If no students have ranked a project then that project is removed from \\(P\\).\n\nThis construction of students, projects, supervisors, associations, capacities and preference lists is a game and is denoted by \\((S,P,U)\\). This game is used to model instances of SA.\n\n\n\nA matching \\(M\\) is any mapping between \\(S\\) and \\(P\\). If a pair \\((s, p) \\in S \\times P\\) are matched in \\(M\\), we say that \\(M(s) = p\\) and \\(s \\in M^{-1}(p)\\). We also note that since each supervisor \\(u \\in U\\) oversees their projects (by definition), their matching can be referred to as the union of its projects' matchings:\n\\[M^{-1}(u) = \\bigcup_{p \\in L^{-1}(u)} M^{-1}(p) \\subseteq S\\]\nA matching is only considered valid if all of the following are satisfied:\n\n\nFor all \\(s \\in S\\) with a match we have \\(M(s) \\in f(s)\\).\nFor all \\(p \\in P\\) we have \\(M^{-1}(p) \\subseteq g_p(u)\\) and \\(|M^{-1}(p)| \\leq c_p\\).\nFor all \\(u \\in U\\) we have \\(M^{-1}(u) \\subseteq g(u)\\) and \\(|M^{-1}(u)| \\leq c_u\\).\n\n\nAs always, a valid matching is considered stable if it does not contain any blocking pairs.\n\n\n\nA pair \\((s, p)\\) is said to block a matching \\(M\\) if all the following hold:\n\n\nThe student has a preference of the project, i.e. \\(p \\in f(s)\\).\nEither \\(s\\) is unmatched or they prefer \\(p\\) to \\(M(s) = p'\\).\nAt least one of the following is true, where \\(u = L(p)\\):\n\n\nBoth \\(p\\) and \\(u\\) are under-subscribed, i.e. \\(|M^{-1}(p)| &lt; c_p\\) and \\(|M^{-1}(u)| &lt; c_u\\).\n\\(|M^{-1}(p)| &lt; c_p\\) and \\(|M^{-1}(u)| = c_u\\), and either \\(M(s) = p' \\in L^{-1}(u)\\) or \\(u\\) prefers \\(s\\) to their worst current match \\(s' \\in M^{-1}(u)\\).\n\\(|M^{-1}(p)| = c_p\\) and \\(u\\) prefers \\(s\\) to the project's worst student \\(s \\in M^{-1}(p)\\).\n\n\n\n\nThe notion of preference is equivalent to that in SM."
  },
  {
    "objectID": "docs/discussion/student_allocation.html#an-example",
    "href": "docs/discussion/student_allocation.html#an-example",
    "title": "The student-allocation problem",
    "section": "",
    "text": "Consider the following instance of SA. There are five students - Avery, Blake, Cleo, Devon, Everest - in their final year of university. As part of this year, they may apply to do a project. There are two members of staff providing these projects - Dr. Xavier and Prof. Yeo. Each supervisor may take at most three students and each offer two projects with space for two students on each. The players' preferences are described in the graph below:\n\n\n\nimage\n\n\nNote that in this particular example, the students are ranked in the same order by both supervisors (as is often the case in real-world applications of SA). Now consider the matching below:\n\n\n\nimage\n\n\nThis matching is invalid, and none of the conditions for validity have been met. Specifically:\n\nAvery has been allocated Dr. Yeo's first project despite not ranking it (and likewise for Dr. Yeo and the project)\nDr. Yeo's first project has been allocated a total of three students which exceeds its capacity of two.\nIn addition to this, Dr. Yeo has been allocated a fourth student, violating their capacity constraint.\n\nWith a few changes, we can make this matching valid. Swapping Avery and Cleo with Devon is a start since they are Dr. Xavier's favourite students after Blake. Then we can move Devon to Y2 as this is their most preferred project. Doing this gives the following matching:\n\n\n\nimage\n\n\nUnfortunately, and despite our efforts to accommodate people's preferences, this matching is not stable. Here we have two blocking pairs, \\((E, X2)\\) and \\((E, Y2)\\). Although Everest prefers X1 to either of these projects, they do not form a blocking pair as X1 is full and Dr. Xavier prefers Avery and Cleo to Everest.\nSo, in order to overcome these blocking pairs without creating more, Devon must be swapped with Everest. This also feels like the fairest move given that Everest outranks Devon. The following graph displays this new, stable matching:\n\n\n\nimage\n\n\nIt also happens that this matching is student-optimal as well as being stable and valid."
  },
  {
    "objectID": "docs/discussion/student_allocation.html#the-algorithm",
    "href": "docs/discussion/student_allocation.html#the-algorithm",
    "title": "The student-allocation problem",
    "section": "",
    "text": "Finding stable and optimal solutions to SA is easily motivated since those solutions would solve the real-world problem they model. Actually implementing this in the real world is described in more detail in this tutorial.\nAs with HR, there are two algorithms implemented in Matching to solve instances of SA, one to handle the optimality of each party (students and project/supervisors). These algorithms, taken from AIM07, follow a similar structure to those for HR in that they take advantage of the inherent structure of the game. Again, each party-optimal algorithm provides a unique, stable matching for an instance of SA.\n\n\n\nAssign all students to be unmatched, and all supervisors (and their projects) to be totally unsubscribed.\nTake any student \\(s\\) that is unmatched and has a non-empty preference list, and consider their most preferred project \\(p\\). Let \\(u = L(p)\\). Assign \\(s\\) to be matched to \\(p\\) (and thus \\(u\\)).\nIf \\(p\\) is over-subscribed, find its worst current match \\(s'\\). Unmatch \\(p\\) and \\(s'\\). Else if \\(u\\) is over-subscribed, find their worst current match \\(s'\\) and the project \\(p'\\) that \\(s'\\) is assigned to. Unmatch \\(p'\\) and \\(s'\\).\nIf \\(p\\) is at capacity, find their worst current match \\(s'\\). For each successor \\(t \\in g_p(u)\\) to \\(s'\\), delete the pair \\((t, p)\\) from the game by removing \\(p\\) from \\(f(t)\\) and \\(t\\) from \\(g(u)\\) (and thus \\(g_p(u)\\)).\nIf \\(u\\) is at capacity, find their worst current match \\(s'\\). For each successor \\(t \\in g(u)\\) to \\(s'\\), delete the pair \\((t, p)\\) from the game.\nGo to 1 until there are no such students left, then end.\n\n\n\n\n\nAssign all students to be unmatched, and all supervisors (and their projects) to be totally unsubscribed.\nTake any supervisor \\(u\\) that is under-subscribed and whose preference list contains at least one student that is not currently matched to at least one acceptable (though currently under-subscribed) project offered by \\(u\\). Consider the supervisor's most preferred such student \\(s\\) and that student's most preferred such project \\(p\\).\nIf \\(s\\) is matched to some other project \\(p'\\) then unmatch them.\nAssign \\(s\\) to be matched to \\(p\\) (and thus \\(u\\)).\nFor each successor \\(p' \\in f(s)\\) to \\(p\\), delete the pair \\((s, p')\\) from the game.\nGo to 1 until there are no such supervisors, then end."
  },
  {
    "objectID": "docs/discussion/changes.html",
    "href": "docs/discussion/changes.html",
    "title": "CHANGES",
    "section": "",
    "text": "Restructure the project to use pyproject.toml and tox\nImprove the documentation (reformatted doc-strings, migrating to Quarto and GitHub Pages)\nMinor fixes to ensure CI"
  },
  {
    "objectID": "docs/discussion/changes.html#v1.4.1---2023-08-30",
    "href": "docs/discussion/changes.html#v1.4.1---2023-08-30",
    "title": "CHANGES",
    "section": "",
    "text": "Restructure the project to use pyproject.toml and tox\nImprove the documentation (reformatted doc-strings, migrating to Quarto and GitHub Pages)\nMinor fixes to ensure CI"
  },
  {
    "objectID": "docs/discussion/changes.html#v1.4---2020-11-04",
    "href": "docs/discussion/changes.html#v1.4---2020-11-04",
    "title": "CHANGES",
    "section": "v1.4 - 2020-11-04",
    "text": "v1.4 - 2020-11-04\n\nAdd abstract classes for players, games and matchings.\nImplement extended algorithm for SR, and clean up HR/SM algorithms.\nMove all of the algorithms to their own module, matching.algorithms."
  },
  {
    "objectID": "docs/discussion/changes.html#v1.3.3---2020-10-15",
    "href": "docs/discussion/changes.html#v1.3.3---2020-10-15",
    "title": "CHANGES",
    "section": "v1.3.3 - 2020-10-15",
    "text": "v1.3.3 - 2020-10-15\n\nMove unmatching to second phase in SR (allows for simple games.)\nMinor docs fixes."
  },
  {
    "objectID": "docs/discussion/changes.html#v1.3.2---2020-07-05",
    "href": "docs/discussion/changes.html#v1.3.2---2020-07-05",
    "title": "CHANGES",
    "section": "v1.3.2 - 2020-07-05",
    "text": "v1.3.2 - 2020-07-05\n\nAdd HR input check for non-positive hospital capacities.\nRemove recursive flag from isort call in CI.\nMinor clean up of README images."
  },
  {
    "objectID": "docs/discussion/changes.html#v1.3.1---2020-05-26",
    "href": "docs/discussion/changes.html#v1.3.1---2020-05-26",
    "title": "CHANGES",
    "section": "v1.3.1 - 2020-05-26",
    "text": "v1.3.1 - 2020-05-26\n\nMinor docs fixes."
  },
  {
    "objectID": "docs/discussion/changes.html#v1.3.0---2020-04-17",
    "href": "docs/discussion/changes.html#v1.3.0---2020-04-17",
    "title": "CHANGES",
    "section": "v1.3.0 - 2020-04-17",
    "text": "v1.3.0 - 2020-04-17\n\nUpdate the self-citation information in paper.bib to v1.3."
  },
  {
    "objectID": "docs/discussion/changes.html#v1.3---2020-04-14",
    "href": "docs/discussion/changes.html#v1.3---2020-04-14",
    "title": "CHANGES",
    "section": "v1.3 - 2020-04-14",
    "text": "v1.3 - 2020-04-14\n\nPlayers are now copied via copy.deepcopy when a game is created and the copies are used, leaving any originals unchanged.\nFormalise test and Python requirements in setup.py.\nRevert flaky forgetting fix from v1.2.1 and correct the flaky tests that were causing the issue.\nReplace the Game class with BaseGame and make it a metaclass via abc.ABCMeta.\nFix bugs in documentation stopping build."
  },
  {
    "objectID": "docs/discussion/changes.html#v1.2.1---2020-02-28",
    "href": "docs/discussion/changes.html#v1.2.1---2020-02-28",
    "title": "CHANGES",
    "section": "v1.2.1 - 2020-02-28",
    "text": "v1.2.1 - 2020-02-28\n\nFinish documentation.\nComplete paper for submission to JOSS.\nCatch flaky forgetting bug in Player."
  },
  {
    "objectID": "docs/discussion/changes.html#v1.2---2020-02-24",
    "href": "docs/discussion/changes.html#v1.2---2020-02-24",
    "title": "CHANGES",
    "section": "v1.2 - 2020-02-24",
    "text": "v1.2 - 2020-02-24\n\nImplement the stable roommates problem.\nAdd example tests to all games.\nFlesh out documentation."
  },
  {
    "objectID": "docs/discussion/changes.html#v1.1---2019-05-10",
    "href": "docs/discussion/changes.html#v1.1---2019-05-10",
    "title": "CHANGES",
    "section": "v1.1 - 2019-05-10",
    "text": "v1.1 - 2019-05-10\n\nImplemented the student-allocation problem.\nAdded capability for large game creation from dictionaries."
  },
  {
    "objectID": "docs/discussion/changes.html#v1.0.2---2019-01-30",
    "href": "docs/discussion/changes.html#v1.0.2---2019-01-30",
    "title": "CHANGES",
    "section": "v1.0.2 - 2019-01-30",
    "text": "v1.0.2 - 2019-01-30\n\nIndividuals forget the names of others one at a time rather than all instances at once as previously.\nAdd citation file."
  },
  {
    "objectID": "docs/discussion/changes.html#v1.0.1---2019-01-28",
    "href": "docs/discussion/changes.html#v1.0.1---2019-01-28",
    "title": "CHANGES",
    "section": "v1.0.1 - 2019-01-28",
    "text": "v1.0.1 - 2019-01-28\n\nUpdate travis.yml to stop failures. Dodgy support for Python &lt;3.6.\nAdd new badges."
  },
  {
    "objectID": "docs/discussion/changes.html#v1.0---2019-01-22",
    "href": "docs/discussion/changes.html#v1.0---2019-01-22",
    "title": "CHANGES",
    "section": "v1.0 - 2019-01-22",
    "text": "v1.0 - 2019-01-22\nThe main changes are as follows:\n\nInstead of passing dictionaries to an algorithm function, lists of matching.Player instances must be created for the two matching parties.\nEach of these instances have a few attributes but, most importantly, they take a name (this should be unique to the party) and a list (or tuple) ranking their preferences of the names of the other party’s members.\nWith these lists of Player instances, each type of matching game now has its own solver class (e.g. the hospital-resident assignment problem uses matching.HospitalResident) with various methods to solve the game and then check the stability/validity of a matching.\n\nFurther details given in new README.rst."
  },
  {
    "objectID": "docs/discussion/changes.html#v0.1---2018-03-22",
    "href": "docs/discussion/changes.html#v0.1---2018-03-22",
    "title": "CHANGES",
    "section": "v0.1 - 2018-03-22",
    "text": "v0.1 - 2018-03-22\nFirst release. Two main algorithm functions for SM and HR."
  },
  {
    "objectID": "docs/discussion/other_packages/index.html",
    "href": "docs/discussion/other_packages/index.html",
    "title": "Other packages",
    "section": "",
    "text": "There exist a number of other open-source packages for completing game-theoretic tasks.\nBelow is a non-exhaustive list of such packages.\n\n\n\n\n\n\n\n\n\n\n\n\nAxelrod\n\n\n\nPython\n\n\n\nA research library aimed at the study of the Iterated Prisoners’ Dilemma.\n\n\n\n\n\n\n\n\n\n\nEvolutionaryGames\n\n\n\nR\n\n\n\nA comprehensive set of tools for evolutionary game theory.\n\n\n\n\n\n\n\n\n\n\nGambit\n\n\n\nPython\n\n\n\nA C library with a Python API and an online interface for computing large games.\n\n\n\n\n\n\n\n\n\n\nNashpy\n\n\n\nPython\n\n\n\nCompute the Nash equilibria of two-player normal form games.\n\n\n\n\n\n\n\n\n\n\nPyNFG\n\n\n\nPython\n\n\n\nFor modelling network form games.\n\n\n\n\n\n\n\n\n\n\ngtree\n\n\n\nR\n\n\n\nFor specifying extensive form games, using Gambit under the hood for computation.\n\n\n\n\n\n\n\n\n\n\nmatchingR\n\n\n\nR\n\n\n\nA backend in C++ provides fast solutions to many types of matching problems, including stable marriages, college admissions, and house allocations.\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "docs/tutorials/stable_roommates.html",
    "href": "docs/tutorials/stable_roommates.html",
    "title": "Finding pairs of roommates",
    "section": "",
    "text": "In this tutorial we will be setting up and solving an intance of the stable roommates problem.\nWe will be using an example adapted from the show Seinfeld (David and Seinfeld 1989), where four friends (Jerry, George, Elaine, and Kramer) are trying to make pairs so that they can share two 2-bedroom apartments. We refer to these friends as players from here on."
  },
  {
    "objectID": "docs/tutorials/stable_roommates.html#creating-the-players",
    "href": "docs/tutorials/stable_roommates.html#creating-the-players",
    "title": "Finding pairs of roommates",
    "section": "Creating the players",
    "text": "Creating the players\nTo begin, we create an instance of the Player class for each player.\n\nfrom matching import Player\n\nplayers = [\n    Player(\"jerry\"),\n    Player(\"george\"),\n    Player(\"kramer\"),\n    Player(\"elaine\"),\n]\n\nWe set everyone’s preferences using the Player.set_pref() method. Each player’s preferences must be a list of all the other Player instances, ordered according to how much they like each other player.\nA nice way to do this is by unpacking our list of players:\n\njerry, george, elaine, kramer = players\n\njerry.set_prefs([george, elaine, kramer])\ngeorge.set_prefs([jerry, kramer, elaine])\nelaine.set_prefs([jerry, kramer, george])\nkramer.set_prefs([elaine, george, jerry])"
  },
  {
    "objectID": "docs/tutorials/stable_roommates.html#running-the-game",
    "href": "docs/tutorials/stable_roommates.html#running-the-game",
    "title": "Finding pairs of roommates",
    "section": "Running the game",
    "text": "Running the game\nWith our now complete Player instances, we pass the lists of players to the StableRoommates class:\n\nfrom matching.games import StableRoommates\n\ngame = StableRoommates(players)\n\nFinally, we solve the game.\n\ngame.solve()\n\n{jerry: george, george: jerry, kramer: elaine, elaine: kramer}\n\n\nThankfully, there is a stable matching here (it’s not guaranteed), and our foursome of friends can furcate forthwith!"
  },
  {
    "objectID": "docs/tutorials/hospital_resident.html",
    "href": "docs/tutorials/hospital_resident.html",
    "title": "Allocating university medics to hospital placements",
    "section": "",
    "text": "For this tutorial, we will be using HR to solve a real-world problem.\nImagine that we represent a centralised body responsible for assigning newly qualified doctors to their hospital posts. This job is already done by computers around the world using software like matching, and now we can do it, too."
  },
  {
    "objectID": "docs/tutorials/hospital_resident.html#collecting-and-reading-the-data",
    "href": "docs/tutorials/hospital_resident.html#collecting-and-reading-the-data",
    "title": "Allocating university medics to hospital placements",
    "section": "Collecting and reading the data",
    "text": "Collecting and reading the data\nThe data for this tutorial have been archived on Zenodo. The source code used to generate them is here.\nWe can load in the data as Python dictionaries with the urllib and PyYAML libraries.\n\nimport urllib\nimport yaml\n\n\ndef read_yaml_to_dict(where, filename):\n    \"\"\"Read in the YAML data from the URL.\"\"\"\n\n    url = \"/\".join((where, filename))\n    with urllib.request.urlopen(url) as response:\n        dictionary = yaml.safe_load(response.read())\n\n    return dictionary\n\n\nbase_url = \"https://zenodo.org/record/3688091/files\"\n\nresident_preferences = read_yaml_to_dict(base_url, \"residents.yml\")\nhospital_preferences = read_yaml_to_dict(base_url, \"hospitals.yml\")\nhospital_capacities = read_yaml_to_dict(base_url, \"capacities.yml\")\n\nAs it turns out, this game is fairly large. There are 200 medics (or residents) applying to 7 hospitals with a total of 210 spaces available:\n\nnum_residents = len(resident_preferences)\nnum_hospitals = len(hospital_preferences)\ntotal_spaces = sum(hospital_capacities.values())\n\nnum_residents, num_hospitals, total_spaces\n\n(200, 7, 210)"
  },
  {
    "objectID": "docs/tutorials/hospital_resident.html#creating-the-players",
    "href": "docs/tutorials/hospital_resident.html#creating-the-players",
    "title": "Allocating university medics to hospital placements",
    "section": "Creating the players",
    "text": "Creating the players\nWith the data read in, we can create the players for our game.\n\n\n\n\n\n\nTip\n\n\n\nWe don’t need to worry about cleaning the data as they were created to form a valid game instance.\n\n\nThis particular instance is not only too large to be done by hand, but we also won’t be creating the players manually. Instead, we will use the HospitalResident.create_from_dictionaries() method.\n\nfrom matching.games import HospitalResident\n\ngame = HospitalResident.create_from_dictionaries(\n    resident_preferences, hospital_preferences, hospital_capacities\n)"
  },
  {
    "objectID": "docs/tutorials/hospital_resident.html#running-the-game",
    "href": "docs/tutorials/hospital_resident.html#running-the-game",
    "title": "Allocating university medics to hospital placements",
    "section": "Running the game",
    "text": "Running the game\nNow, we have a complete game instance to solve.\nWe have the option to find a resident- or hospital-optimal solution. In this case, as is often done in reality, we will be using the former.\n\nsolution = game.solve(optimal=\"resident\")"
  },
  {
    "objectID": "docs/tutorials/hospital_resident.html#checking-the-matching",
    "href": "docs/tutorials/hospital_resident.html#checking-the-matching",
    "title": "Allocating university medics to hospital placements",
    "section": "Checking the matching",
    "text": "Checking the matching\nThe solution is a dictionary-like object with hospitals as keys and lists of their matched residents as values.\n\nfor hospital, residents in solution.items():\n    print(f\"{hospital} ({len(residents)} / {hospital.capacity}): {residents}\")\n\nDewi Sant (30 / 30): [067, 022, 023, 158, 139, 065, 160, 131, 011, 137, 039, 045, 013, 046, 072, 037, 086, 152, 144, 154, 130, 040, 010, 159, 083, 019, 169, 193, 168, 079]\nPrince Charles (29 / 30): [027, 133, 106, 081, 051, 044, 069, 157, 110, 119, 129, 107, 135, 034, 007, 194, 198, 061, 087, 041, 183, 136, 059, 178, 009, 008, 031, 070, 026]\nPrince of Wales (30 / 30): [143, 128, 048, 175, 078, 132, 151, 030, 124, 138, 088, 004, 199, 173, 017, 097, 064, 025, 112, 181, 171, 196, 111, 035, 185, 156, 140, 001, 197, 177]\nRoyal Glamorgan (30 / 30): [073, 118, 096, 089, 014, 126, 142, 053, 021, 018, 104, 015, 147, 153, 033, 113, 146, 076, 123, 042, 117, 024, 029, 000, 016, 134, 058, 166, 075, 174]\nRoyal Gwent (27 / 30): [028, 105, 115, 095, 054, 006, 120, 161, 187, 164, 091, 141, 036, 184, 071, 155, 066, 182, 189, 002, 191, 068, 090, 145, 163, 121, 180]\nSt. David (30 / 30): [149, 101, 150, 172, 165, 020, 049, 094, 060, 116, 056, 005, 093, 188, 043, 108, 192, 092, 167, 114, 012, 063, 077, 162, 085, 195, 032, 099, 084, 127]\nUniversity (24 / 30): [109, 003, 057, 170, 176, 100, 122, 080, 038, 082, 102, 052, 062, 055, 047, 074, 050, 179, 125, 186, 148, 103, 098, 190]\n\n\nOne common criterion for success when solving games like this is whether all of the medics have been assigned.\nThe following code allows us to see which residents (if any) were not matched to a hospital.\n\nmatched_residents = []\nfor _, residents in solution.items():\n    for resident in residents:\n        matched_residents.append(resident.name)\n\nunmatched_residents = set(resident_preferences.keys()).difference(\n    matched_residents\n)\nunmatched_residents\n\nset()\n\n\nWe’ve done it!\nEvery resident has successfully been assigned to a hospital of their choice with stability and fairness."
  }
]